<!DOCTYPE html>
<html>
  <head>
    <title>Chart Navigator [Alpha]</title>
    
    <meta name="viewport" content="initial-scale=1.0, maximum-scale=1.0, user-scalable=no, width=device-width">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-title" content="Ragnar [Alpha]">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="theme-color" content="#000000">
    <link rel="apple-touch-icon" href="/images/sailboat.png">
    <link rel="manifest" href="/manifest.json">
    <link rel="prefetch" href="images/wu_logo_130x80.png">
    <link rel="prefetch" href="images/left-arrow.png">
    <link rel="prefetch" href="images/right-arrow.png">
    <link rel="prefetch" href="images/compass4.png">
    <link rel="prefetch" href="images/location-arrow.png">
    <link rel="prefetch" href="images/navigation-arrow.png">
    <link rel="prefetch" href="images/magnifier.png">

    <link rel="stylesheet" href="lib/OpenLayers/4.3.1/ol.css" type="text/css">
    <link rel="stylesheet" href="stylesheets/alertify.core.css" type="text/css">
    <link rel="stylesheet" href="stylesheets/alertify.bootstrap.css" type="text/css">
    <link rel="stylesheet" href="stylesheets/bootstrap.min.css" type="text/css">
    <link rel="stylesheet" href="stylesheets/keyboard.min.css" type="text/css">

    <script src="javascripts/geolocation.js"></script>
    <script src="javascripts/clock.js"></script>
    <script src="javascripts/swipedetect.js"></script>
    <script src="javascripts/map.js"></script>
    <script src="javascripts/forecast.js"></script>

    <script src="lib/alertify.min.js"></script>
    <script src="lib/OpenLayers/4.3.1/ol.js"></script>
    <script src="lib/Chart.js"></script>

    <script src="lib/jquery.min.js"></script>
    <script src="lib/jquery.keyboard.min.js"></script>
    <script src="lib/bootstrap.min.js"></script>

    <style>
      hr {
        margin-top: .25em;
        margin-bottom: .25em;
      }
      .forecast {
        overflow-y: scroll;
      }
      table {
        font-family: arial, sans-serif;
        border-collapse: collapse;
      }
      td, th {
        border: none;
        text-align: left;
        padding: 8px;
      }
      tr:nth-child(even) {
        background-color: rgba(0,65,135,.3);
      }
      tr:nth-child(odd) {
        background: rgb(255,255,235);
      }

      .alertify-button {
        background: rgba(0,65,135,.7);
        color: white;
      }
      .alertify-button-ok:focus {
        background: rgba(0,65,135,.9);
        color: white;
      }
      .alertify-button-ok:active {
        background: rgba(0,65,135,.95);
        color: white;
      }
      .alertify-button-ok:hover {
        background: rgba(0,65,135,1);
        color: white;
      }
      .ol-attribution ul {
        font-size: 100%;
        font-weight: bold;
        position: relative;
        bottom: 3px;
      }
      .ol-attribution a {
        display: none;
      }
      .popover-title {
        height: 30px;
        background:rgba(0,65,135,.5);
        color: white;
      }
      .popover-title .close {
        position: relative;
        bottom: 6px;
      } 
      .popover-title a {
        color: white;
        display: inline-block;
        opacity: 1;
      }
      .popover-content {
        min-width: 270px;
        font-size: 12px;
      }
      .ui-keyboard {
        background: white;
        background: -webkit-linear-gradient(rgba(0,65,135, .85), lightblue);
        top: 100%;
        left: -12.5%;
        border-radius: 8px;
        border: 1px solid;
        box-shadow: 2px 2px 2px rgba(50,50,50,.5);
      }
      .ui-keyboard-button {
        font-size: 1.35em;
      }
      .ui-keyboard-button:active {
        background: -webkit-linear-gradient(rgba(0,65,135,.5), gray);
        box-shadow: 1px 1px 1px gray;
        color:white;
      }
      .search-results {
        width: 100%;
      }
      .ol-zoom {
        background: gray;
      }
      .ol-zoom:hover {
        background: lightblue;
      }
      .tablet .ol-zoom {
        width: 50px;
        height: 80px;
      }
      .tablet .ol-zoom-in {
        width: 44px;
        height: 36px;
      }
      .tablet .ol-zoom-out {
        width: 44px;
        height: 36px;
      }
      .ol-custom {
        background: gray;
      }
      .ol-custom:hover {
        background: lightblue;
      }
      .tide-chart {
        position: absolute;
        top: .5em;
        right: .5em;
        background: rgb(255,255,235);
        opacity: .95;
        width: 25%;
        border-radius: 8px;
        box-shadow: 3px 3px 4px rgba(50,50,50,.5);
      }
      .ol-touch .tide-chart {
        width: 85%;
        right: 0px;
      }
      .tablet .tide-chart {
        width: 33%;
      }
      .show-tide {
        top: .5em;
        right: .5em;
      }
      .ol-touch .show-tide {
        right: 0px;
      }
      .clock {
        position: absolute;
        top: 20em;
        right: .5em;
        background: rgb(255,255,235);
        opacity: .95;
        border-radius: 8px;
        box-shadow: 3px 3px 4px rgba(50,50,50,.5);
      }
      .ol-touch .clock {
        top: 150px;
        right: 0px;
      }
      .tablet .clock {
        top: 160px;
      }
      .show-clock {
        position: absolute;
        top: 20em;
        right: .5em;
      }
      .ol-touch .show-clock {
        top: 150px;
        right: 0px;
      }
      .tablet .show-clock {
        top: 160px;
      }
      .tracking {
        top: 85px;
        left: .5em;
        background: brown;
      }
      .ol-touch .tracking {
        top: 95px;
      }
      .tablet .tracking {
        top: 120px;
        width: 50px;
        height: 50px;
      }
      .tablet .tracking-btn {
        width: 44px;
        height: 44px;
      }
      .tablet .tracking-img.center {
        display: block;
        margin: 0 auto;
      }

      .search {
        top: 112px;
        left: .5em;
      }
      .ol-touch .search {
        top: 130px;
      }
      .tablet .search {
        top: 171px;
        width: 50px;
        height: 50px;
      }
      .tablet .search-btn {
        width: 44px;
        height: 44px;
      }
      .tablet .search-img.center {
        display: block;
        margin: 0 auto;
      }

      .dest {
        top: 140px;
        left: .5em;
      }
      .ol-touch .dest {
        top: 165px;
      }
      .tablet .dest {
        top: 222px;
        width: 50px;
        height: 50px;
      }
      .tablet .dest-btn {
        width: 44px;
        height: 44px;
      }
      .tablet .dest-img.center {
        display: block;
        margin: 0 auto;
      }

      .shutdown {
        bottom: 2em;
        left: .5em;
        visibility: hidden;
      }
      .tablet .shutdown {
        width: 50px;
        height: 50px;
      }
      .tablet .shutdown-btn {
        width: 44px;
        height: 44px;
      }
      .tablet .shutdown-img.center {
        display: block;
        margin: 0 auto;
      }

      .chart {
        background-color: white;
        opacity: 0.7;
        visibility: hidden;
      }
      .location {
        background-color: yellow;
        font-weight: bold;
        font-size: 110%;
        font-family: 'arial black';
        bottom: 1.25em;
        opacity: .95;
        text-align: center;
        box-shadow: 2px 2px 2px rgba(50,50,50,.5);
        right: 0;
      }
      .set-course {
        position: absolute;
        left: .5em;
        top: .4em;
      }
    </style>
    <style type="text/css">
      html, body, .map {
        margin: 0;
        padding: 0;
        width: 100%;
        height: 100%;
      }
    </style>

  </head>
  <body>

    <div id="map" class="map"></div>
    <div style="display: none;">
      <div id="popup" class="popup"</div>
    </div>

    <script>
      const defaultZoom = 13;
      const locationTimeout = 1000;

      var popup = null;

      var app = {
        setCourse() {
          this.setDestination(popup.getPosition());
          //document.getElementById('dest').style.visibility = 'visible';
        },
        cancelCourse() { 
          this.setDestination(null);
          //document.getElementById('dest').style.visibility = 'hidden';
        },
        hasDestination() {
          return this.destination.point !== null;
        },
        isDestination(pos) {
          return this.destination.point !== null && equalPoint(pos, this.destination.point)
        },
        map: null,
        tzOffset: (new Date()).getTimezoneOffset() * 60000,
        powerClick: 0,

        location: {
          current: null,
          prev: {
            point: null,
            name: 'current location'
          }
        },
        destination: {
          coord: null,
          point: null,
          place: null,
        },

        tide: {
          station: null,
          chart: {
            line: null,
            lastUpdated: new Date(),
            visible: true,
          },
          offset: 0
        },
        clock: {
          visible: true,
          positioned: 0
        }
      }

      // Raspberry or iPad?
      // FIXME: armv7 for raspberry maybe not such a good idea
      if (navigator.userAgent.match(/armv7/) ||
          navigator.userAgent.match(/ipad/i)) {
        var elem = document.getElementById('map');
        elem.className += ' tablet';
      }

      //
      // Utilities
      //
      function isFullScreen() {
        return window.innerHeight===screen.height;
      }

      function equalPoint(p1, p2) {
        if (!p1) {
          return !p2;
        }
        if (!p2) {
          return !p1;
        }
        return p1[0]===p2[0] && p1[1]===p2[1];
      }

      function updateTracking(active) {
        let elem = document.getElementById('tracking');
        if (elem) {
          if (active) {
            elem.style.background = 'green';
          }
          else {
            elem.style.background = 'brown';
          }
        }
      }

      /**
       * Custom control for activating geolocation / gps tracking
       */
      const trackingControl = function(opt_options) {
        const options = opt_options || {};

        const button = document.createElement('button');
        const iconLoc = document.createElement('img');
        iconLoc.src = 'images/location-arrow.png';
        iconLoc.className = 'tracking-img';

        button.appendChild(iconLoc);

        button.title = 'Track current location';
        button.className = 'tracking-btn';

        const iconNav = document.createElement('img');
        iconNav.src = 'images/navigation-arrow.png';
        iconNav.className = 'tracking-img';

        var handler = function() {
          if (geolocation.isTracking()) {
            app.map.toggleRotation();
          }
          else {
            geolocation.start();
          }
          updateWaterLevel(app.map.showCurrentLocation(true)._coord);
          if (app.map._rotateView) {
            button.removeChild(iconLoc);
            button.appendChild(iconNav);
          }
          else {
            if (iconNav.parentElement===button) {
              button.removeChild(iconNav);
              button.appendChild(iconLoc);
            }
          }
        }
        button.addEventListener('click', handler, false);

        var element = document.createElement('div');
        element.id = 'tracking';
        element.className = 'tracking ol-custom ol-unselectable ol-control';
        element.appendChild(button);

        ol.control.Control.call(this, {
          element: element,
          target: options.target
        });
      }
      ol.inherits(trackingControl, ol.control.Control);
      
      /**
       * Custom control for searching for a specific location on the charts
       */
      const searchControl = function(opt_options) {
        //
        // Virtual keyboard layout
        //
        const kbdLayout = {
          "name" : "ms-US English (Latin)",
          "lang" : ["en"],
          "normal" : [
            "` 1 2 3 4 5 6 7 8 9 0 - = {bksp}",
            "q w e r t y u i o p [ ] \u005c",
            "a s d f g h j k l ; '",
            "{shift} \u005c z x c v b n m , . / {shift}",
            "{space}"
          ],
          "shift" : [
            "~ ! @ # $ % ^ & * ( ) _ + {bksp}",
            "Q W E R T Y U I O P { } |",
            "A S D F G H J K L : \u0022",
            "{shift} | Z X C V B N M < > / {shift}",
            "{space}"
          ]
        };      
        const options = opt_options || {};

        const button = document.createElement('button');
        const icon = document.createElement('img');
        icon.src = 'images/magnifier.png';
        icon.className = 'search-img';

        button.appendChild(icon);
        button.title = 'Search';
        button.className = 'search-btn';

        var handler = function() {
          alertify.prompt('', function(valid, value) {
            if (valid) {
              value = value.trim();
              if (value) {
                searchLocation(value, app.map._location._coord);
              }
            }
          });

          let form = document.getElementById('alertify-form');

          if (location.search === '?touch') {
            $('#alertify-text').keyboard({
              autoAccept: true,
              layout: 'custom',
              customLayout: kbdLayout,
              usePreview: false,
              visible: function(e, keyboard, el) {
                const kbdElem = document.getElementById('alertify-text_keyboard');
                form.appendChild(kbdElem);
              }
            });
          }
        }
        button.addEventListener('click', handler, false);

        var element = document.createElement('div');
        element.className = 'search ol-custom ol-unselectable ol-control';
        element.appendChild(button);

        ol.control.Control.call(this, {
          element: element,
          target: options.target
        });
      }
      ol.inherits(searchControl, ol.control.Control);

      /**
       * Custom control to show the current destination
       */
      const destControl = function(opt_options) {
        const options = opt_options || {};

        const button = document.createElement('button');
        const icon = document.createElement('img');
        //icon.src = 'images/pointer-icon.png';
        icon.src = 'images/circular-target.png';
        icon.className = 'dest-img';
        button.appendChild(icon);
        button.title = 'Show target location / forecast';
        button.className = 'dest-btn';
        var handler = function() {
          if (popup.place && app.hasDestination()) {
            if (popup.visible) {
              $(popup.getElement()).popover('destroy');
              popup.visible = popup.show = false;  
            }
            geolocation.stop();
            const loc = app.map.showDestination();
            updatePopup(loc._point, app.destination.place, loc._coord);
          }
          else {
            const m = app.map;
            const forecast = equalPoint(m._location._point, m._view.getCenter());
            m._view.animate({
              center: m._location._point,
              duration: 2000
            }, function() {
              if (forecast) {
                let coord = m._location._coord;
                getForecast(coord[0], coord[1]);
              }
            })
          }
        }
        button.addEventListener('click', handler, false);
        button.addEventListener('touchstart', handler, false);

        var element = document.createElement('div');
        element.id = 'dest';
        element.className = 'dest ol-custom ol-unselectable ol-control';
        element.appendChild(button);
        //element.style.visibility = 'hidden';

        ol.control.Control.call(this, {
          element: element,
          target: options.target
        });
      }
      ol.inherits(destControl, ol.control.Control);

      /**
       * Shutdown button
       */
      const shutdownControl = function(opt_options) {
        const options = opt_options || {};

        const button = document.createElement('button');
        const icon = document.createElement('img');
        icon.src = 'images/shutdown.png';
        icon.className = 'shutdown-img';
        button.appendChild(icon);
        button.title = 'Shutdown system';
        button.className = 'shutdown-btn';

        const shutdown = function() {
          alertify.confirm('Do you really want to <b>shutdown</b> the system?',
            function(accept) {
              if (accept) {
                const xmlHttp = new XMLHttpRequest();
                xmlHttp.open('GET', '/shutdown/now');
                xmlHttp.send();
              }
            }
          );
        }
        const reboot = function() {
          alertify.confirm('Do you really want to <b>reboot</b> the system?',
            function(accept) {
              if (accept) {
                const xmlHttp = new XMLHttpRequest();
                xmlHttp.open('GET', '/shutdown/reboot');
                xmlHttp.send();
              }
            }
          );
        }
        button.addEventListener('click', function() {
          if (app.powerClick===0) {
            setTimeout(function() {
              if (app.powerClick > 1) {
                reboot();
              }
              else {
                shutdown();
              }
              app.powerClick = 0;
            }, 250);
          }
          ++app.powerClick;
        }, false);

        var element = document.createElement('div');
        element.className = 'shutdown ol-custom ol-unselectable ol-control';
        element.appendChild(button);
        element.id = 'shutdown';

        ol.control.Control.call(this, {
          element: element,
          target: options.target
        });
      }
      ol.inherits(shutdownControl, ol.control.Control);

      /**
       * Custom control for drawing water levels
       */
      const tideChartControl = function(opt_options) {
        const options = opt_options || {};

        const canvas = document.createElement('canvas');
        canvas.id = 'tideChart';
        var element = document.createElement('div');
        element.className = 'tide-chart ol-unselectable ol-control';
        element.appendChild(canvas);

        ol.control.Control.call(this, {
          element: element,
          target: options.target
        });
      }
      ol.inherits(tideChartControl, ol.control.Control);


      function newOpenCloseWidget(titleOpen, titleClosed, elemName, elemClass, flag) {
        const button = document.createElement('button');
        const iconClose = document.createElement('img');
        const iconOpen = document.createElement('img');
        iconClose.src = 'images/right-arrow.png';
        iconOpen.src = 'images/left-arrow.png';
        button.appendChild(iconClose);
        button.title = titleOpen;
        button.id = elemClass;

        var handler = function() {
          var elem = document.getElementById(elemName).parentElement;
          if (!flag) {
            elem.style.visibility = 'visible';
            button.title = titleOpen;
            button.appendChild(iconClose);
            if (iconOpen.parentElement===button) {
              button.removeChild(iconOpen);
            }
          }
          else {
            elem.style.visibility = 'hidden';
            button.title = titleClosed;
            button.appendChild(iconOpen);
            if (iconClose.parentElement===button) {
              button.removeChild(iconClose);
            }
          }
          flag ^= true;
        }
        button.addEventListener('click', handler, false);

        //this results in the button being way too trigger-happy
        //button.addEventListener('touchstart', handler, false);

        var element = document.createElement('div');
        element.className = elemClass + ' ol-custom ol-unselectable ol-control';
        element.appendChild(button);

        app['hide_' + elemName] = function() {
          flag = true;
          handler();
        }
        return element;
      }


      /**
       * Button for showing / hiding water levels (tide charts)
       */
      const showTideControl = function(opt_options) {
        const options = opt_options || {};
        const element = newOpenCloseWidget(
          'Hide tide info', 'Show tide info', 'tideChart', 'show-tide', app.tide.chart.visible);

        ol.control.Control.call(this, {
          element: element,
          target: options.target
        });
      }
      ol.inherits(showTideControl, ol.control.Control);


      /**
       * Custom control for clock / compass
       */
      const clockControl = function(opt_options) {
        const options = opt_options || {};

        const canvas = document.createElement('canvas');
        canvas.id = 'clock';
        canvas.width = canvas.height = 268; // best for iPhone
        // hack for the Raspberry PI
        if (navigator.userAgent.match(/armv7/)) {
          canvas.width = canvas.height = 277;
        }
        let element = document.createElement('div');
        element.className = 'clock ol-unselectable ol-control';
        element.appendChild(canvas);

        ol.control.Control.call(this, {
          element: element,
          target: options.target
        });
      }
      ol.inherits(clockControl, ol.control.Control);
      
      const showClockControl = function(opt_options) {
        const options = opt_options || {};
        const element = newOpenCloseWidget('Hide clock', 'Show clock', 'clock', 'show-clock', app.clock.visible);

        ol.control.Control.call(this, {
          element: element,
          target: options.target
        });
      }
      ol.inherits(showClockControl, ol.control.Control);


      /**
       * Custom control for displaying current location
       */
      const locationControl = function(opt_options) {
        const options = opt_options || {};
        var element = document.createElement('div');
        element.className = 'location ol-unselectable ol-control';
        element.id = 'location';
        element.innerHTML = convertDMS(options.coords);
        ol.control.Control.call(this, {
          element: element,
          target: options.target
        });
      }
      ol.inherits(locationControl, ol.control.Control);

      function enableShutdown() {
        const xmlHttp = new XMLHttpRequest();
        xmlHttp.onreadystatechange = function() {
          if (xmlHttp.readyState === 4 && xmlHttp.status === 200) {
            if (JSON.parse(xmlHttp.responseText)) {
              let elem = document.getElementById('shutdown');
                elem.style.visibility = 'visible';
            }
          }
        }
        xmlHttp.open('GET', 'shutdown/supported');
        xmlHttp.send();
      }

      const getDeviceOrientation = function() {
        if (!navigator.userAgent.match(/mobile/i)
         || navigator.platform.match(/ipad/i)) {
          return 'default';
        }
        let elem = document.getElementById('tideChart');
        if (!elem) {
          return 'default';
        }
        elem = elem.parentElement;
        switch (window.orientation) {
        case 90:
        case -90:
          elem.style.width = '60%';
          return 'landscape';
        default:
          elem.style.width = '80%';
          return 'portrait';
        }
      };

      const handleDeviceOrientation = function() {
        app.clock.positioned = 0;
        repositionWidgets();
      };

      function repositionWidgets() {
        if (app.clock.reposition) {
          clearInterval(app.clock.reposition);
        }
        app.clock.reposition = setInterval(positionClock, 200);
      }

      /**
       * Position the clock/compass widget relative to tide graph
       */
      function positionClock() {
        // give it a few frames to stabilize
        if (++app.clock.positioned >= 10) {
          if (app.clock.reposition) {
            clearInterval(app.clock.reposition);
            app.clock.reposition = null;
          }
          return;
        }
        const orientation = getDeviceOrientation();
        let elem = document.getElementById('tideChart').parentElement;
        const rect = elem.getBoundingClientRect();
        const canvas = document.getElementById('clock');
        elem = canvas.parentElement;
        let top = 0;
        let right = '.5em';

        switch (orientation) {
        case 'landscape':
          canvas.width = canvas.height = rect.height;
          elem.style.top = rect.top + 'px';
          elem.style.left = (rect.left - rect.height - 4) + 'px';
          right = window.innerWidth -rect.left + 4;
          top = rect.top;
          break;

        case 'portrait':
          right = 0;
        default:
          canvas.width = canvas.height = rect.width;
          elem.style.top = (rect.bottom + 4) + 'px';
          elem.style.left = rect.left + 'px';
          top = rect.bottom + 4;
          break;
        }
        elem.style.width = elem.style.height = canvas.height + 'px';

        elem = document.getElementById('show-clock').parentElement;
        elem.style.top = top + 'px';
        elem.style.right = right + 'px';

        startClock();
        positionLocation();
      }


      function positionLocation() {
        let elem = document.getElementById('tideChart').parentElement;
        const rect = elem.getBoundingClientRect();
        elem = document.getElementById('location');
        elem.style.left = rect.left + 'px';
        elem.style.width = rect.width + 'px';
      }


      function dateHelper(val) {
        return Math.floor(val / 10).toString() + (val % 10);
      }

      /**
       * Helper for formatting begin_date and end_date for water level requests
       */
      function formatDateTimeUTC(date) {
        const month = date.getUTCMonth() + 1;
        const day = date.getUTCDate();
        const hour = date.getUTCHours();
        const minute = date.getUTCMinutes()
        return date.getUTCFullYear().toString() + Math.floor(month / 10) + month % 10 + 
          + Math.floor(day / 10) + day % 10 + ' ' + Math.floor(hour / 10)
          + Math.floor(hour % 10) + ':' + Math.floor(minute / 10) + minute % 10;
      }


      function formatRequestRange(now, id) {
        now.setTime(now.getTime() - 12 * 3600 * 1000);
        const begin = formatDateTimeUTC(now);
        now.setTime(now.getTime() + 24 * 3600 * 1000);
        const end = formatDateTimeUTC(now);
        return '&begin_date=' + begin + '&end_date=' + end
          + '&time_zone=GMT&station=' + id + '&units=english&format=json';
      }


      /**
       * Update tide chart:
       * 1) ask the backend for the closest water level station to current location
       * 2) in response to the async request, processWaterLevelStation sends a 
       *    request to the NOAA web service, using a time interval centered around 
       *    the current time.
       */
      function updateWaterLevel(coord) {

        function getWaterLevel(station) {
          const now = new Date();

          if (app.tide.station && station.Id === app.tide.station.Id) {
            //
            // same station? update every 5 minutes
            //
            if (now.getTime() < app.tide.chart.lastUpdated.getTime() + 5 * 60 * 1000) {
              return;
            }
          }
          app.tide.station = station;
          app.tide.chart.lastUpdated = now;
          app.tzOffset = -station.tzOffset;

          now.setTime(now.getTime() + app.tide.offset * 24 * 3600 * 1000);
          const stationInfo = 'Station: ' + station.Id + ' ' + station.Name + ' ' + station.State;
          const currentTime = now.toISOString();

          const useNOAAData = location.search == '?noaa';
          var url;
          if (useNOAAData) {
            url = 'https://tidesandcurrents.noaa.gov/api/datagetter?product=predictions&datum=MLLW' 
            + formatRequestRange(now, app.tide.station.Id);
          } 
          else {
            url = 'tides/' + app.tide.station.Id + '/' + currentTime;
          }
        const xmlHttp = new XMLHttpRequest();
          xmlHttp.onreadystatechange = processWaterLevelRequest.bind(null, stationInfo);
          xmlHttp.open('GET', url);
          xmlHttp.send();
        }

        /**
         * Process response from backend.
         */
        function processWaterLevelStation(event) {
          const xmlHttp = event.currentTarget;
          
          if (xmlHttp.readyState === 4) {
            if (xmlHttp.status === 200) {
              getWaterLevel(JSON.parse(xmlHttp.responseText));
            }
            else {
              console.log(xmlHttp.response.text);
            }
          }
        }
        
        /**
         * Process response from NOAA
         */
        function processWaterLevelRequest(stationInfo, event) {

          function tickDate(t) {
            const arr = t.split(/[- :]/);
            const date = new Date(arr[0], arr[1]-1, arr[2], arr[3], arr[4]);
            // Convert to local time
            date.setTime(date.getTime() - app.tzOffset);

            const a = date.toString().split(' ');
            const timeString = (date.getMonth() + 1)
              + '/' + date.getDate()
              + ' ' + dateHelper(date.getHours())
              + ':' + dateHelper(date.getMinutes());
                                  
            return [date, timeString];
          }

          const xmlHttp = event.currentTarget;

          if (xmlHttp.readyState===4 && xmlHttp.status===200) {
            const predictions = JSON.parse(xmlHttp.responseText).predictions;

            let labels = []
            const datasets = [ {
              data: [],
              borderColor: 'blue',
              borderWidth: 2,
              backgroundColor: 'rgba(0,65,135,.3)',
              pointBorderColor: 'black',
              pointBackgroundColor: 'orange',
              pointRadius: new Array(predictions.length).fill(0),
            } ]

            const data = datasets[0].data;
            const now = new Date();
            now.setTime(now.getTime() + now.getTimezoneOffset() * 60000
              - app.tzOffset + app.tide.offset * 24 * 3600 * 1000);

            let closest = 0;
            for (let i = 0; i < predictions.length; ++i) {
              labels.push(predictions[i].t);
              data[i] = predictions[i].v;
              const t = tickDate(predictions[i].t);
              if (closest===0 && t[0].getTime() >= now.getTime()) {
                closest = i;
              }
            }
            let valMin = 99999;
            let iMin = closest;
            for (let i = closest; i < predictions.length; ++i) {
              const val = parseFloat(predictions[i].v);
              if (val < valMin) {
                iMin = i;
                valMin = val;
              }
              if (val > valMin) {
                if (iMin===closest) {
                  valMin = val;
                }
                else {
                  break;
                }
              }
            }
            let iMax = closest;
            let valMax = -99999;
            for (let i = closest; i < predictions.length; ++i) {
              const val = parseFloat(predictions[i].v);
              if (val > valMax) {
                iMax = i;
                valMax = val;
              }
              if (val < valMax) {
                if (iMax===closest) {
                  valMax = val;
                }
                else {
                  break;
                }
              }
            }
            
            function rebuildTicks(c) {
              function label(ticks, i) {
                return tickDate(ticks[i])[1];
              }
              const ticks = c.ticks;
              c.ticks = [];
              c.ticks[0] = ['', label(ticks, 0)];
              c.ticks[closest] = ['', label(ticks, closest)];
              c.ticks[ticks.length-1] = ['', label(ticks, ticks.length-1)];
              c.ticks[iMin] = label(ticks, iMin).split(' ')[1];
              c.ticks[iMax] = label(ticks, iMax).split(' ')[1];
            }


            datasets[0].pointRadius[closest] = 6;

            const ctx = document.getElementById('tideChart');

            if (app.tide.chart.line) {
              app.tide.chart.line.destroy();
            }
            else {
              swipedetect(ctx, function(dir) {
                if (dir==='right') {
                  --app.tide.offset;
                }
                else if (dir==='left') {
                  ++app.tide.offset;
                }
                else {
                  return;
                }
                app.tide.chart.lastUpdated.setTime(0);
                updateWaterLevel(app.location.current);
              });
            }

            app.tide.chart.line = new Chart.Line(ctx, {

              data: {
                labels: labels,
                datasets: datasets
              },

              options: {

                animation: {
                  duration: 0,

                  onComplete: function() {
                    const ctx = this.chart.ctx;
                    const fillStyle = ctx.fillStyle;
                    const font = ctx.font;
                    ctx.fillStyle = 'navy';
                    ctx.textBaseline='middle';
                    ctx.textAlign='left';
                    ctx.font = 'bold 18px calibri';
                    const meta = this.getDatasetMeta(0);
                    for (let i = 0; i != meta.data.length; ++i) {
                      if (meta.data[i]._model.radius < 6) {
                        continue;
                      }
                      const data = this.data.datasets[0].data;
                      const value = Math.ceil(10 * data[i]) / 10 + "'";
                      ctx.fillText(value, 35, 25);
                      break;
                    }
                    ctx.fillStyle = fillStyle;
                    ctx.font = font;
                  }
                },
                legend: {
                  display: false
                },
                title: {
                  display: true,
                  fontSize: 12,
                  padding: 0,
                  position: 'bottom',
                  text: stationInfo
                },
                tooltips: {
                  callbacks: {
                    title: function(items, data) {
                      const val = tickDate(data.labels[items[0].index])[1];
                      return val;
                    }
                  }
                },

                scales: {
                  yAxes: [ {
                      gridLines: {
                        color: 'lightblue',
                        borderDash: app.tide.offset ? [8, 4] : [0, 0]
                      },
                    }
                  ],

                  xAxes: [ {
                      gridLines: {
                        color: 'blue',
                        borderDash: app.tide.offset ? [8, 4] : [0, 0]
                      },

                      ticks: {
                        fontSize: 12,
                        maxRotation: 0,
                        autoSkip: false,
                      },

                      afterBuildTicks: rebuildTicks
                    },
                  ]
                },
              },
            });
          }
        }
        const xmlHttp = new XMLHttpRequest();
        xmlHttp.onreadystatechange = processWaterLevelStation;
        xmlHttp.open('GET', 'nearestWaterLevelStation/' + coord[1] + '/' + coord[0]);
        xmlHttp.send();
      }


      function updateCurrents(coord) {
        const xmlHttp = new XMLHttpRequest();
        xmlHttp.onreadystatechange = processCurrentsStation;
        xmlHttp.open('GET', 'nearestCurrentsStation/' + coord[1] + '/' + coord[0]);
        xmlHttp.send();
      }


      function processCurrentsStation(event) {
        const xmlHttp = event.currentTarget;
        if (xmlHttp.readyState === 4 && xmlHttp.status === 200) {
          console.log(xmlHttp.responseText);
          const station = JSON.parse(xmlHttp.responseText);
          const now = new Date();            

          const url = 
              'https://tidesandcurrents.noaa.gov/api/datagetter?product=currents'
              + formatRequestRange(now, station.Id);
          xmlHttp.onreadystatechange = processCurrents;
          xmlHttp.open('GET', url);
          xmlHttp.send();
        }
      }


      function processCurrents(event) {
        const xmlHttp = event.currentTarget;
        if (xmlHttp.readyState === 4 && xmlHttp.status === 200) {
          console.log(xmlHttp.responseText);
        }
      }


      function showPopup() {
        if (popup.visible && !popup.shown) {
          popup.shown = true;
          const elem = popup.getElement();
          $(elem).popover('show');
          function closePopup() {
            $(elem).popover('destroy'); 
            popup.visible = popup.shown = false;
          }
          function setDestination(pos) {
            closePopup();
            app.destination.point = pos;
            if (app.destination.point) {
              app.destination.place = popup.place;
              app.destination.coord = popup.coord;

              app.map.setDestination();
            }
            else {
              app.map.removeDestination();
            }
            lastInteraction = null;
            geolocation.start();
          }
          if (!app.setDestination) {
            app.setDestination = setDestination;
          }
          const closeBtn = document.getElementById('close-popup');
          closeBtn.onclick = closePopup;
          closeBtn.ontouchstart = closePopup;

          if (navigator.userAgent.match(/mobile/i)) { // small screen?
            app.hide_clock();
            app.hide_tideChart();
          }
        }
      }

      function getForecast(lon, lat) {
        forecast(lon, lat, function(err, res) {
          const msg = err ? err.message : formatForecast(res, lon, lat);
          alertify.alert(msg);
          if (!isFullScreen()) {
            let elem = document.getElementById('alertify-ok');
            if (elem) {
              const url = 'http://marine.weather.gov/MapClick.php?lat=' + lat + '&lon=' + lon;
              let button = document.createElement('a');
              button.target = '_blank';
              button.href = url;
              button.innerHTML = 'Marine Weather';
              button.className = 'alertify-button alertify-button-ok';
              elem.parentElement.appendChild(button);
            }
          }
          let elem = document.getElementById('forecast');
          if (elem) {
            elem.style.height = window.innerHeight * .6 + 'px';
          }
        })          
      }

      function updatePopup(pos, place, coord) {
        popup.place = place;
        popup.coord = coord;

        let html = '<b>' + place.name + '</b>';
        if (place.state) {
          html += ', ' + place.state;
        }

        html += '<br>' + convertDMS(coord);

        function distance(d) {
          if (d===0 && geolocation.coord) {
            const coord = [ geolocation.coord.lon, geolocation.coord.lat ];
            d = getDistanceFromLonLat(popup.coord, coord) * 3440;
            app.location.prev.name = 'current location';
          }
          return '<br>' + Math.floor(d * 100) / 100
            + ' nautical miles from ' + app.location.prev.name + '.';

        }

        if (app.isDestination(pos)) {
          const d = getDistanceFromLonLat(app.destination.coord, app.location.current) * 3440;
          html += distance(d);
          app.location.prev.name = app.destination.place.name;
          if (app.destination.place.state) {
            app.location.prev.name += ', ' + app.destination.place.state;
          }
        }
        else {
          html += distance(place.dist);
          app.location.prev.name = place.name;
          if (place.state) {
            app.location.prev.name += ', ' + place.state;
          }
        }
        app.location.current = coord;

        const e = popup.getElement();

        $(e).popover({
          'animation': false,
          'html': true,
          'placement': 'top',
          'content': html,
          'title': '<a href="#" id="close-popup" class="close">&times;</a>'
        });
        if (!equalPoint(app.location.point, app.destination.point)) {
          app.location.prev.point = app.location.point;
        }
        popup.setPosition(pos);
        popup.shown = false;
        popup.visible = true; // popover on map postrender

        const xmlHttp = new XMLHttpRequest();
        xmlHttp.onreadystatechange = function() {
          if (xmlHttp.readyState === 4 && xmlHttp.status === 200) {
            const w = JSON.parse(xmlHttp.responseText);

            const imageUrl = '/images/wu_logo_130x80.png';
            html += '<b>Weather Underground</b><image width="15%" src="' + imageUrl + '"/> ';

            html += w.weather + ' ' + w.temp + ' Feels like: ' + w.feelslike
              + ' Wind: ' + w.wind 
              + ' (' + w.wind_degrees + '&deg;, '  + w.wind_mph + ' MPH)'
              + ' Humidity: ' + w.humidity
              + ' Visibility: ' + w.visibility + ' miles'
              + ' Observed at ' + w.station + '.'

            if (app.isDestination(pos)) {
              html += '<hr><a class="btn btn-primary btn-xs" onClick="app.cancelCourse()">Cancel Course</a>  ';
            }
            else {
              html += '<hr><a class="btn btn-primary btn-xs" onClick="app.setCourse()">Set Course</a>  ';
            }
            html += '<button class="btn btn-primary btn-xs" onClick="getForecast('
              + coord[0] + ',' + coord[1] + ')">NOAA Forecast</button>';
            $(e).popover('destroy');
            $(e).popover({
              'animation': false,
              'html': true,
              'placement': 'top',
              'content': html,
              'title': '<a href="#" id="close-popup" class="close">&times;</a>'
            });
            popup.shown = false;
            app.map.render();
          }
        }
        xmlHttp.open('GET', '/weather/' + coord[0] + '/' + coord[1]);
        xmlHttp.send();
      }


      function searchLocation(name, coord) {
 
        function buildSelection(matches) {
          let selectHtml = '<b>Nearest Matches</b><br>';
          selectHtml += '<select id="searchResults" class="search-results">';
          for (let i = 0; i < matches.length; ++i) {
            const m = matches[i];
            selectHtml += '<option value="[' + m.lon + ',' + m.lat + ']">';
            selectHtml += m.name;
            if (m.stateName) {
              selectHtml += ', ' + m.stateName;
            }
            if (m.state) {
              selectHtml += ' (' + m.state + ')';
            }
            selectHtml += '</option>';
          }
          selectHtml += '</select>';
          return selectHtml;
        }

        const url = 'search/' + name + '/' + coord[0] + '/' + coord[1];
        const xmlHttp = new XMLHttpRequest();
        xmlHttp.onreadystatechange = function() {
          if (xmlHttp.readyState === 4 && xmlHttp.status === 200) {
            const matches = JSON.parse(xmlHttp.responseText);
            if (matches && matches.length) {
              const selectHtml = buildSelection(matches);
              
              alertify.confirm(selectHtml, function(accept) {
                if (!accept) {
                  return;
                }
                const elem = document.getElementById('searchResults');
                if (!elem) {
                  return;
                }
                const srchCoord = JSON.parse(elem.options[elem.selectedIndex].value);
                if (geolocation.isTracking()) {
                  geolocation.stop();
                }

                if (app.map.getView().getZoom() < defaultZoom) {
                    app.map.getView().setZoom(defaultZoom);
                }

                updatePopup(
                  app.map.setInspectLocation(srchCoord)._point,
                  matches[elem.selectedIndex],
                  srchCoord
                );
                app.map.showInspectLocation();
              });
            }
            else {
              alertify.alert('<b>No matches</b>');
            }
          }
        }
        xmlHttp.open('GET', url);
        xmlHttp.send();
      }
      

      function convertDMS(coords) {
        return ol.coordinate.toStringHDMS(coords);
      }


      function updateDefault() {
        if (!app.location.current) {
          app.location.current = [-122.4049, 47.6810] // Shilshole Bay
          app.location.prev.name = 'Shilshole Bay';
          app.map.setCurrentLocation(app.location.current);
          app.map.showCurrentLocation();
          updateCoords()
        }
      }


      function initialize() {
        const controls = [
          new tideChartControl(),
          new showTideControl(),
          new clockControl(),
          new showClockControl(),
          new locationControl(),
          new trackingControl(),
          new searchControl(),
          new destControl(),
          new shutdownControl()
        ];

        app.map = new Map({
          controls: controls,
          target: 'map',
          defaultZoom: defaultZoom,
          onLocationUpdate: function(coord) {
            updateWaterLevel(coord);
          },
          onUpdateView: function(view) {
          }
        });
        enableShutdown();
        
        popup = new ol.Overlay({
          element: document.getElementById('popup')
        });
        app.map.addOverlay(popup);

        app.map.on('postrender', function() {
          showPopup();
          repositionWidgets();
        });
        app.map.on('change:size', function() {
          app.clock.positioned = 0;
        });
        document.getElementById('location').addEventListener('click', function () {
          const loc = app.map._currentLocation;
          if (loc) {
            getForecast(loc._coord[0], loc._coord[1]);
          }
        })
        app.hide_clock();
      }

      function updateCoords() {
        elem = document.getElementById('location');
        if (elem) {
          elem.innerHTML = convertDMS(app.location.current);
        }
      }

      initialize();

      let updateTimeout = setInterval(updateDefault, locationTimeout);

      var geolocation = new Geolocation({
        onSuccess: function(coord) {
          if (coord.lon && coord.lat) {
            if (updateTimeout) {
              clearInterval(updateTimeout);
              updateTimeout = null;
            }
            updateTracking(true);
            app.location.current = [ coord.lon, coord.lat ];
            app.location.prev.name = 'current location';

            app.map.setCurrentLocation(app.location.current);
            app.map.showCurrentLocation();

            updateCoords();
          }
        },
        onError: function(err) {
          updateTracking(false);
          updateDefault();
        },
        onStop: function() {
          app.tide.station = null;
          updateTracking(false);
        },
        onCompass: function() {
          if (app.map && app.map._updating) {
            return;
          }
          if (geolocation.isTracking()) {
            if (app.clock.visible) {
              drawClock(clock.ctx, clock.radius);
              app.clock.positioned = 0;
              positionClock();
            }
            app.map.updateFeatures();
          }
        },
        timeout: locationTimeout
      });

      startClock();

      swipedetect(clock.canvas, function(dir) {
        geolocation.changeSpeedUnit();
      }, true);
      geolocation.start();
      if (!navigator.geolocation) {
        updateDefault();
      }

      window.addEventListener('orientationchange', handleDeviceOrientation);

    </script>
    <div>Compass icons made by <a href="http://www.freepik.com" title="Freepik">Freepik</a> from <a href="https://www.flaticon.com/" title="Flaticon">www.flaticon.com</a> is licensed by <a href="http://creativecommons.org/licenses/by/3.0/" title="Creative Commons BY 3.0" target="_blank">CC 3.0 BY</a></div>
  </body>
</html>

