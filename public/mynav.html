<!DOCTYPE html>
<html>
  <head>
    <title>Chart Navigator [Alpha]</title>
    <link rel="stylesheet" href="lib/OpenLayers/4.2.0/ol.css" type="text/css">
    <meta name="viewport" content="initial-scale=1.0, user-scalable=no, width=device-width">
    <script src="lib/OpenLayers/4.2.0/ol.js"></script>
    <script src="lib/Chart.js"></script>
    <style>
      .tide-chart {
        top: .5em;
        right: .5em;
        background-color: white;
        width: 35%;
      }
      .ol-touch .tide-chart {
        width: 70%;
        right: 0px;
      }
    </style>
    <style>
      .re-center {
        top: 125px;
        left: .5em;
      }
      .ol-touch .re-center {
        top: 125px;
      }
    </style>
    <style type="text/css">
      html, body, .map {
        margin: 0;
        padding: 0;
        width: 100%;
        height: 100%;
      }
    </style>
    <style>
      .location {
        font-weight: bold;
        font-style: italic;
        background-color: white;
        opacity: 0.7;
        visibility: hidden;
      }
    </style>
    <style>
      .chart {
        background-color: white;
        opacity: 0.7;
        //visibility: hidden;
      }
    </style>
  </head>
  <body>
    <div id="location" class="location"></div>
    <div id="map" class="map"></div>
    <script>
      const defaultZoom = 12;
      var savedZoom = defaultZoom;

      var chartTilesets = null; // current tilesets, stringified
      var chartLayers = [];     // current layers
      var marker = null;        // layer that marks current position
      var map = null;           // the map object

      var currentLocation = null;
      var geoLocationWatchId = null;

      var locationOverlay = null;
      var waterLevelStation = null;
      var tideChart = null;

      /**
       * Custom control for re-centering the map to the current geolocation
       */
      recenterControl = function(opt_options) {
        var options = opt_options || {}

        const button = document.createElement('button');
        const icon = document.createElement('img');
        icon.src = 'images/pointer-icon.png';
        button.appendChild(icon);

        var handler = function() {
          map.getView().setZoom(savedZoom);
          trackLocation();
        }
        button.addEventListener('click', handler, false);
        button.addEventListener('touchstart', handler, false);

        var element = document.createElement('div');
        element.className = 're-center ol-unselectable ol-control';
        element.appendChild(button);

        ol.control.Control.call(this, {
          element: element,
          target: options.target
        });
      }
      ol.inherits(recenterControl, ol.control.Control);

     
      /**
       * Custom control for drawing water levels
       */
      tideChartControl = function(opt_options) {
        var options = opt_options || {}

        const canvas = document.createElement('canvas');
        canvas.id = 'tideChart';
        var element = document.createElement('div');
        element.className = 'tide-chart ol-unselectable ol-control';
        element.appendChild(canvas);

        ol.control.Control.call(this, {
          element: element,
          target: options.target
        });
      }
      ol.inherits(tideChartControl, ol.control.Control);


      /**
       * Construct position marker layer
       */
      function curPosLayer(xy, iconUrl) {
        var iconFeature = new ol.Feature({
          geometry: new ol.geom.Point(xy),
          name: 'Current position',
        });

        var iconStyle = new ol.style.Style({
          image: new ol.style.Icon(/** @type {olx.style.IconOptions} */ ({
            anchor: [0.5, 46],
            anchorXUnits: 'fraction',
            anchorYUnits: 'pixels',
            src: iconUrl
          }))
        });
        iconFeature.setStyle(iconStyle);

        var vectorSource = new ol.source.Vector({
          features: [iconFeature]
        });

        return new ol.layer.Vector({
          source: vectorSource,
        });
      }


      /**
       * Ask the backend for the tilesets that match the current coordinates
       */ 
      function getChartTilesets(coord, callback) {
        const tilesetsUrl = 'tilesets/noaa/' + coord[0] + '/' + coord[1];
        var xmlHttp = new XMLHttpRequest();
        xmlHttp.onreadystatechange = function() {
          if (xmlHttp.readyState == 4 && xmlHttp.status == 200) {
            callback(xmlHttp.responseText);
          }
        }
        xmlHttp.open("GET", tilesetsUrl);
        xmlHttp.send();
      }


      /**
       * Ask the backend for the best chart tilesets for the given coordinates
       * and recompute the chart layers if necessary (if tilesets changed).
       */
      function updateChartLayers(coord, view, callback) {
        const viewMaxRes = view.getMaxResolution();

        getChartTilesets(coord, function(tilesets) {
          if (tilesets !== chartTilesets) {
            chartTilesets = tilesets;
            console.log('----- Chart tilesets changed -----');
            //
            // remove old chart layers
            //
            if (map) {
              res = map.getView().getResolution();
              for (i = 0; i < chartLayers.length; ++i) {
                map.removeLayer(chartLayers[i]);
              }
              chartLayers = [];
            }

            let hMax = null;
            let maxRes = viewMaxRes;

            //
            // apply new chart layers 
            //
            JSON.parse(tilesets).map(function(tileset) {
              if (!hMax) {
                hMax = tileset.height;
              }
              maxRes = Math.ceil((tileset.height * viewMaxRes) / hMax);

              const url = 'tiles/noaa/' + tileset.ident + '/{z}/{x}/{y}.png';
              const layer = new ol.layer.Tile({
                source: new ol.source.XYZ({url: url}),
                maxResolution: maxRes,
                opacity: 0.95
              });
              layer.ident = tileset.ident;
              chartLayers.push(layer);
            })

            let prev = null;
            for (i = chartLayers.length - 1; i >= 0; --i) {
              let layer = chartLayers[i];
              if (prev) {
                if (layer.getMaxResolution() / prev.getMaxResolution() > 3) {
                  layer.setMinResolution(prev.getMaxResolution());
                }
                else {
                  layer.setMinResolution(prev.getMinResolution());
                }
              }
              console.log(i, layer.ident, layer.getMinResolution(), layer.getMaxResolution());
              prev = layer;
            }

            if (map) {
              for (i = 0; i != chartLayers.length; ++i) {
                let layer = chartLayers[i];
                map.addLayer(layer);
              }
            }
          }
          callback();
        });
      }

      function createOverlays(map, pos) {
        let elem = document.getElementById('location');
        locationOverlay = new ol.Overlay({element: elem});
        map.addOverlay(locationOverlay);
        locationOverlay.setPosition(pos);
        elem.style.visibility = 'visible';
      }

      /**
       * Construct / update the map object
       */
      function updateMap(coord, iconUrl = 'images/pointer.png') {
    
        const pos = ol.proj.fromLonLat(coord);

        const view = map ? map.getView() : new ol.View({
          center: pos,
          zoom: defaultZoom,
          minZoom: 4,
          maxZoom: 17,
          enableRotation: false,
        });
        
        if (!ol.extent.containsXY(view.calculateExtent(), pos[0], pos[1])) {
          view.setCenter(pos);
        }
        
        function baseLayer() {
          return new ol.layer.Tile({
            //source: new ol.source.XYZ({url:'tiles/osm/{a-c}/{z}/{x}/{y}.png'})
            source: new ol.source.XYZ({url:'tiles/wikimedia/osm-intl/{z}/{x}/{y}.png'})
          });
        }

        updateChartLayers(coord, view, function() {

          if (!map) {
            map = new ol.Map({
              controls: ol.control.defaults(
                {attribution: false}
              ).extend([
                new tideChartControl(),
                new recenterControl(),
                new ol.control.FullScreen(),
                new ol.control.ScaleLine({units: 'nautical'}),
              ]),
              target: 'map',
              layers: [
                baseLayer(),
              ].concat(chartLayers),
              view: view
            });

            map.on('dblclick', function(e) {
              e.preventDefault();
              if (geoLocationWatchId) {
                navigator.geolocation.clearWatch(geoLocationWatchId);
                geoLocationWatchId = null;
                savedZoom = map.getView().getZoom();
                alert('Location tracking paused. Click the location button to resume.');
              }
              const coord = e.coordinate;
              const latLon = ol.proj.transform(coord, 'EPSG:3857', 'EPSG:4326');
              updateMap(latLon, 'images/view.png');
            });

            createOverlays(map, pos);
          }

          locationOverlay.setPosition(pos);

          if (marker) {
            map.removeLayer(marker);
          }
          marker = curPosLayer(pos, iconUrl);
          map.addLayer(marker);
        });
        
        var elem = document.getElementById('location');
        elem.innerHTML = convertDMS(coord);

        updateWaterLevel(coord);
      }

      function dateHelper(val) {
        var result = '';
        if (val < 10) {
          result += '0';
        }
        result += val;
        return result;
      }

      function updateWaterLevel(coord) {
        var xmlHttp = new XMLHttpRequest();
        xmlHttp.onreadystatechange = function() {
          if (xmlHttp.readyState == 4 && xmlHttp.status == 200) {
            const station = JSON.parse(xmlHttp.responseText);
            if (waterLevelStation && station.Id == waterLevelStation.Id) {
              return;
            }
            waterLevelStation = station;
            // 
            // Get station info
            // 
            let label = 'Station: ' + station.Id;
            if (station.Name) {
              label += ' ' + station.Name;
            }
            if (station.State) {
              label += ' ' + station.State;
            }

            const date1 = new Date();
            const date2 = new Date();
            //date1.setDate(date1.getDate() - 1);
            date2.setDate(date2.getDate() + 1);
            //const url = station.DataAPI + 'datagetter?product=predictions' 
            const url = 'https://tidesandcurrents.noaa.gov/api/datagetter?product=predictions' 
              + '&begin_date=' + date1.getUTCFullYear() + dateHelper(date1.getUTCMonth() + 1)
              + dateHelper(date1.getUTCDate())
              + '&end_date=' + date2.getUTCFullYear() + dateHelper(date2.getUTCMonth() + 1)
              + dateHelper(date2.getUTCDate())
              + '&datum=MLLW&station=' + station.Id + '&time_zone=GMT&units=english&interval=&format=json';

            console.log(url);
            var xmlHttp2 = new XMLHttpRequest();
            xmlHttp2.onreadystatechange = function() {
              if (xmlHttp2.readyState == 4 && xmlHttp2.status == 200) {

                let labels = []
                let datasets = [ {
                  label: label,
                  data: [],
                  borderWidth: 1
                } ]
                const predictions = JSON.parse(xmlHttp2.responseText).predictions;
                for (i = 0; i < predictions.length; ++i) {
                  labels.push(predictions[i].t);
                  datasets[0].data.push(predictions[i].v);
                }

                if (tideChart) {
                  tideChart.data = {
                    labels: labels,
                    datasets: datasets
                  }
                  tideChart.update();
                }
                else {
                  const ctx = document.getElementById('tideChart').getContext('2d');

                  tideChart = new Chart(ctx, {
                    type: 'line',
                    data: {
                      labels: labels,
                      datasets: datasets
                    },
                    options: {
                      scales: {
                        xAxes: [{ display: false }]
                      }
                    }
                  });
                }
              }
            }
            xmlHttp2.open("GET", url);
            xmlHttp2.send();
          }
        }
        const url = 'nearestWaterLevelStation/' + coord[1] + '/' + coord[0];
        xmlHttp.open("GET", url);
        xmlHttp.send();
      }


      function convertDMS(coords) {
        return ol.coordinate.toStringHDMS(coords);
      }


      /** 
       * Track geolocation
       */
      function trackLocation() {

        function update(position) {
          console.log(position);
          currentLocation = [position.coords.longitude, position.coords.latitude];
          updateMap(currentLocation);
        }

        function error(error) {
          //
          // TODO: recover?
          //
          console.log(error, error.message);
          if (error.code != error.TIMEOUT) {
            alert(error.message);
          }
        }

        const options = {
          enableHighAccuracy: true,
          timeout: 3000,
          maximumAge: 5000,
        };

        if (geoLocationWatchId) {
            navigator.geolocation.clearWatch(geoLocationWatchId);
            geoLocationWatchId = null;
        }
        geoLocationWatchId = navigator.geolocation.watchPosition(update, error, options);
        console.log('geoLocationWatchId', geoLocationWatchId);
      }

      trackLocation();

    </script>
  </body>
</html>

