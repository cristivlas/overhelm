<!DOCTYPE html>
<html>
  <head>
    <title>Chart Navigator [Alpha]</title>
    <link rel="stylesheet" href="lib/OpenLayers/4.2.0/ol.css" type="text/css">
    <link rel="stylesheet" href="stylesheets/alertify.core.css" type="text/css">
    <link rel="stylesheet" href="stylesheets/alertify.bootstrap.css" type="text/css">
    <meta name="viewport" content="initial-scale=1.0, user-scalable=no, width=device-width">
    <script src="lib/alertify.min.js"></script>
    <script src="lib/OpenLayers/4.2.0/ol.js"></script>
    <script src="lib/Chart.js"></script>
    <script src="javascripts/geolocation.js"></script>
    <style>
      .tide-chart {
        top: .5em;
        right: .5em;
        background-color: rgb(255,255,235);
        opacity: .97;
        width: 35%;
      }
      .ol-touch .tide-chart {
        width: 75%;
        right: 0px;
      }
      .tablet .tide-chart {
        width: 35%;
      }
      .show-tide {
        top: .5em;
        right: .5em;
        background-color: rgb(255,255,235);
      }
      .ol-touch .show-tide {
        right: 0px;
      }
      .tablet .show-tide {
        right: 0px;
      }
      .re-center {
        top: 85px;
        left: .5em;
      }
      .ol-touch .re-center {
        top: 95px;
      }
      .chart {
        background-color: white;
        opacity: 0.7;
        visibility: hidden;
      }
      .location {
        background-color: yellow;
        font-weight: bold;
        font-size: 120%;
        font-family: monospace;
				bottom: 2em;
				left: .5em;
        opacity: .7;
      }
      .speed {
        bottom: 4em;
        left: .5em;
        width: 120px;
        height: 25px;
        text-align: center;
        font-size: 120%;
        font-weight: bold;
        font-family: monospace;
        color: white;
        background-color: navy;
        opacity: 0.7;
      }
    </style>
    <style type="text/css">
      html, body, .map {
        margin: 0;
        padding: 0;
        width: 100%;
        height: 100%;
      }
    </style>

  </head>
  <body>
    <div id="map" class="map"></div>
    <script>
      const defaultZoom = 12;
      const locationTimeout = 3000;

      var savedZoom = defaultZoom;

      var chartTilesets = null; // current tilesets, stringified
      var chartLayers = [];     // current layers
      var marker = null;        // layer that marks current position
      var map = null;           // the map object

      var currentLocation = null;

      /*****************************************************************
       * Tides information
       *****************************************************************/
      var waterLevelStation = null;
      var tideChart = null;
      var tideChartTime = new Date();
      var tideChartVisible = true;

      if (navigator.userAgent.match(/armv7/) ||
          navigator.userAgent.match(/ipad/i)) {
        var elem = document.getElementById('map');
        elem.className += ' tablet';
        elem.style.cursor = 'none'; 
      }

      /**
       * Custom control for re-centering the map to the current geolocation
       */
      const recenterControl = function(opt_options) {
        const options = opt_options || {};

        const button = document.createElement('button');
        const icon = document.createElement('img');
        icon.src = 'images/pointer-icon.png';
        button.appendChild(icon);
        button.title = 'Track current location';
        var handler = function() {
          if (!geolocation.isTracking()) {
            map.getView().setZoom(savedZoom);
          }
          geolocation.stop();
          geolocation.start();
        }
        button.addEventListener('click', handler, false);

        var element = document.createElement('div');
        element.className = 're-center ol-unselectable ol-control';
        element.appendChild(button);

        ol.control.Control.call(this, {
          element: element,
          target: options.target
        });
      }
      ol.inherits(recenterControl, ol.control.Control);

     
      /**
       * Custom control for drawing water levels
       */
      const tideChartControl = function(opt_options) {
        const options = opt_options || {};

        const canvas = document.createElement('canvas');
        canvas.id = 'tideChart';
        var element = document.createElement('div');
        element.className = 'tide-chart ol-unselectable ol-control';
        element.appendChild(canvas);

        ol.control.Control.call(this, {
          element: element,
          target: options.target
        });
      }
      ol.inherits(tideChartControl, ol.control.Control);


      /**
       * Button for showing / hiding water levels (tide charts)
       */
      const showTideControl = function(opt_options) {
        const options = opt_options || {};

        const button = document.createElement('button');
        const icon = document.createElement('img');
        icon.src = 'images/right-arrow.png';
        button.appendChild(icon);
        button.title = 'Hide tide chart';
        var handler = function() {
          var elem = document.getElementById('tideChart').parentElement;
          if (!tideChartVisible) {
            elem.style.visibility = 'visible';
            icon.src = 'images/right-arrow.png';
            button.title = 'Hide tide chart';
          }
          else {
            elem.style.visibility = 'hidden';
            icon.src = 'images/left-arrow.png';
            button.title = 'Show tide chart';
          }
          tideChartVisible ^= true;
        }
        button.addEventListener('click', handler, false);

        var element = document.createElement('div');
        element.className = 'show-tide ol-unselectable ol-control';
        element.appendChild(button);

        ol.control.Control.call(this, {
          element: element,
          target: options.target
        });
      }
      ol.inherits(showTideControl, ol.control.Control);


		  /**
			 * Custom control for displaying current location
			 */
			const locationControl = function(opt_options) {
				const options = opt_options || {};
				var element = document.createElement('div');
			  element.className = 'location ol-unselectable ol-control';
				element.id = 'location';
				element.innerHTML = convertDMS(options.coords);
				ol.control.Control.call(this, {
					element: element,
					target: options.target
				});
			}
			ol.inherits(locationControl, ol.control.Control);


      /**
			 * Custom control for displaying speed in knots
			 */
			const speedControl = function(opt_options) {
				const options = opt_options || {};
				var element = document.createElement('div');
			  element.className = 'speed ol-unselectable ol-control';
				element.id = 'speed';
        element.innerHTML = '0 kts';
				ol.control.Control.call(this, {
					element: element,
					target: options.target
				});
			}
			ol.inherits(speedControl, ol.control.Control);
				

      var headingRotation = 0;

      /**
       * Construct position marker layer
       */
      function curPosLayer(xy, iconUrl) {
        var iconFeature = new ol.Feature({
          geometry: new ol.geom.Point(xy),
          name: 'Current position',
        });

        var iconStyle = new ol.style.Style({
          image: new ol.style.Icon(/** @type {olx.style.IconOptions} */ ({
            anchor: [0.5, 0.5],
            anchorXUnits: 'fraction',
            anchorYUnits: 'fraction',
            src: iconUrl,
            rotateWithView: true,
            rotation: geolocation.isTracking() ? headingRotation : 0
          }))
        });
        iconFeature.setStyle(iconStyle);

        var vectorSource = new ol.source.Vector({
          features: [iconFeature]
        });

        return new ol.layer.Vector({
          source: vectorSource,
        });
      }


      /**
       * Ask the backend for the tilesets that match the current coordinates
       */ 
      function getChartTilesets(coord, callback) {
        const tilesetsUrl = 'tilesets/noaa/' + coord[0] + '/' + coord[1];
        const xmlHttp = new XMLHttpRequest();
        xmlHttp.onreadystatechange = function() {
          if (xmlHttp.readyState == 4 && xmlHttp.status == 200) {
            callback(xmlHttp.responseText);
          }
        }
        xmlHttp.open('GET', tilesetsUrl);
        xmlHttp.send();
      }

      function overlap(c1, c2, margin = 0.25) {
        if (c1.lower[1] + margin > c2.upper[1]) {
          return false;
        }
        if (c1.upper[1] < c2.lower[1] + margin) {
          return false;
        }
        if (c1.lower[0] > c2.upper[0]) {
          return false;
        }
        if (c1.upper[0] < c2.lower[0]) {
          return false;
        }
        return true;
      }

      /**
       * Ask the backend for the best chart tilesets for the given coordinates
       * and recompute the chart layers if necessary (if tilesets changed).
       */
      function updateChartLayers(coord, view, callback) {
        const viewMaxRes = view.getMaxResolution();

        getChartTilesets(coord, function(tilesets) {
          if (tilesets !== chartTilesets) {
            chartTilesets = tilesets;
            console.log('----- Chart tilesets changed -----');
            //
            // remove old chart layers
            //
            if (map) {
              res = map.getView().getResolution();
              for (i = 0; i < chartLayers.length; ++i) {
                map.removeLayer(chartLayers[i]);
              }
              chartLayers = [];
            }

            let hMax = null;
            let maxRes = viewMaxRes;

            //
            // apply new chart layers 
            //
            JSON.parse(tilesets).map(function(tileset) {
              if (!hMax) {
                hMax = tileset.height;
              }
              maxRes = Math.ceil((tileset.height * viewMaxRes) / hMax);

              const url = 'tiles/noaa/' + tileset.ident + '/{z}/{x}/{y}';

              const layer = new ol.layer.Tile({
                source: new ol.source.XYZ({url: url}),
                maxResolution: maxRes,
                opacity: 0.95
              });
              layer.ident = tileset.ident;
              layer.upper = tileset.upper;
              layer.lower = tileset.lower;

              chartLayers.push(layer);
            })

            let prev = null;
            for (i = chartLayers.length - 1; i >= 0; --i) {
              let layer = chartLayers[i];
              if (prev) {
                if (overlap(layer, prev)
                    && layer.getMaxResolution() / prev.getMaxResolution() > 1) {
                  layer.setMinResolution(prev.getMaxResolution());
                }
                else {
                  layer.setMinResolution(prev.getMinResolution());
                }
              }
              console.log(i, layer.ident, layer.getMinResolution(), layer.getMaxResolution());
              prev = layer;
            }

            if (map) {
              for (i = 0; i != chartLayers.length; ++i) {
                let layer = chartLayers[i];
                map.addLayer(layer);
              }
            }
          }
          callback();
        });
      }



      /**
       * Construct / update the map object
       */
      function updateMap(coord, iconUrl = 'images/marker.png') {
   
        let elem = document.getElementById('speed');
        if (elem) {
          elem.innerHTML = Math.floor(geolocation.speed * 100) / 100 + ' kts';
        }
        const pos = ol.proj.fromLonLat(coord);

        const view = map ? map.getView() : new ol.View({
          center: pos,
          zoom: defaultZoom,
          minZoom: 3,
          maxZoom: 17,
          enableRotation: false,
        });
        
        if (!ol.extent.containsXY(view.calculateExtent(), pos[0], pos[1])) {
          view.setCenter(pos);
        }
       
        /**
         * Construct the base layer using map tiles from wikimedia
         * (or alternatively: use OpenStreetMaps, etc.) 
         */
        function baseLayer() {
          return new ol.layer.Tile({
            source: new ol.source.XYZ({url:'tiles/wikimedia/osm-intl/{z}/{x}/{y}'})
            //source: new ol.source.XYZ({url:'tiles/osm/{a-c}/{z}/{x}/{y}.png'})
          });
        }

        /**
         * Build marine chart layers
         */
        updateChartLayers(coord, view, function() {
          const tideChartCtrl = new tideChartControl();

          if (!map) {
            map = new ol.Map({
              controls: ol.control.defaults(
                {attribution: false}
              ).extend([
                tideChartCtrl,
                new showTideControl(),
								new locationControl({coords: coord}),
                new recenterControl(),
                new speedControl(),
                new ol.control.ScaleLine({units: 'nautical'}),
              ]),
              target: 'map',
              layers: [
                baseLayer(),
              ].concat(chartLayers),
              view: view
            });

            //
            // USe double click to switch from location tracking to viewing mode
            //
            map.on('dblclick', function(e) {
              e.preventDefault();
              if (geolocation.isTracking()) {
                geolocation.stop();
                savedZoom = map.getView().getZoom();
                alertify.alert('Location tracking paused. Click the location button to resume.');
              }
              const coord = e.coordinate;
              const latLon = ol.proj.transform(coord, 'EPSG:3857', 'EPSG:4326');
              currentLocation = latLon;
              updateMap(latLon, 'images/view.png');
            });

          }

          if (marker) {
            map.removeLayer(marker);
          }
          marker = curPosLayer(pos, iconUrl);
          map.addLayer(marker);
        });
       
        elem = document.getElementById('location');
				if (elem) {
        	elem.innerHTML = convertDMS(coord);
				}
        updateWaterLevel(coord);

        //todo:
        // updateCurrents(coord);
			}


      function dateHelper(val) {
        return Math.floor(val / 10).toString() + (val % 10);
      }

      /**
       * Helper for formatting begin_date and end_date for water level requests
       */
      function formatDateTimeUTC(date) {
        const month = date.getUTCMonth() + 1;
        const day = date.getUTCDate();
        const hour = date.getUTCHours();
        const minute = date.getUTCMinutes()
        return date.getUTCFullYear().toString() + Math.floor(month / 10) + month % 10 + 
          + Math.floor(day / 10) + day % 10 + ' ' + Math.floor(hour / 10)
          + Math.floor(hour % 10) + ':' + Math.floor(minute / 10) + minute % 10;
      }


      function formatRequestRange(now, id) {
        now.setTime(now.getTime() - 12 * 3600 * 1000);
        const begin = formatDateTimeUTC(now);
        now.setTime(now.getTime() + 24 * 3600 * 1000);
        const end = formatDateTimeUTC(now);
        return '&begin_date=' + begin + '&end_date=' + end
          + '&time_zone=GMT&station=' + id + '&units=english&format=json';
      }


      /**
       * Update tide chart:
       * 1) ask the backend for the closest water level station to current location
       * 2) in response to the async request, processWaterLevelStation sends a 
       *    request to the NOAA web service, using a time interval centered around 
       *    the current time.
       */
      function updateWaterLevel(coord) {

        /**
         * Process response from backend.
         */
        function processWaterLevelStation(event) {
          const xmlHttp = event.currentTarget;
          
          if (xmlHttp.readyState == 4) {
            if (xmlHttp.status != 200) {
              console.log(xmlHttp.response.text);
              return;
            }

            let s = JSON.parse(xmlHttp.responseText);

            const now = new Date();
            if (waterLevelStation && s.Id == waterLevelStation.Id) {
              //
              // same station? update every 30 minutes
              //
              if (now.getTime() - tideChartTime.getTime() < 30 * 60 * 1000) {
                return;
              }
            }
            waterLevelStation = s;
            tideChartTime = now;

            const stationInfo = 'Station: ' + s.Id + ' ' + s.Name + ' ' + s.State;

            if (tideChart) {
              tideChart.options.title.text = stationInfo;
            }

            const currentTime = now.toISOString();
            console.log(currentTime);
            const useNOAAData = location.search == '?noaa';
            var url;
            if (useNOAAData) {
              url = 'https://tidesandcurrents.noaa.gov/api/datagetter?product=predictions&datum=MLLW' 
              + formatRequestRange(now, waterLevelStation.Id);
            } 
            else {
              url = 'tides/' + waterLevelStation.Id + '/' + currentTime;
            }
            console.log(url);

            xmlHttp.onreadystatechange = processWaterLevelRequest.bind(null, stationInfo);
            xmlHttp.open("GET", url);
            xmlHttp.send();
          }
        }

        
        /**
         * Process response from NOAA
         */
        function processWaterLevelRequest(stationInfo, event) {
          const xmlHttp = event.currentTarget;

          if (xmlHttp.readyState == 4 && xmlHttp.status == 200) {
            let labels = []
            let datasets = [ {
              label: '',
              data: [],
              backgroundColor: [] ,
            } ]
            const now = new Date();

            const predictions = JSON.parse(xmlHttp.responseText).predictions;

            // Grid lines color and thickness
            let lineColors = []
            let lineWidths = []

            let thresh = 0;
            const step = 3;

            for (i = 0; i < predictions.length; i += step) {
              const t = predictions[i].t;
              const arr = t.split(/[- :]/);
              const date = new Date(arr[0], arr[1]-1, arr[2], arr[3], arr[4]);

              // Convert to local time
              date.setTime(date.getTime() - date.getTimezoneOffset() * 60000);

              const a = date.toString().split(' ');
              labels.push(a[0] + ' ' + dateHelper(date.getHours()) + ':'  + dateHelper(date.getMinutes()));
              datasets[0].data.push(predictions[i].v);
              if (date.getTime() <= now.getTime()) {
                datasets[0].backgroundColor.push('lightblue');
              }
              else {
                datasets[0].backgroundColor.push('blue');
                if (thresh == 0) {
                  thresh = i;
                  const j = Math.floor(i/step) + 1;
                  lineColors[j] = '#606060';
                  lineWidths[j] = 2;
                }
              }
            }

            if (tideChart) {
              tideChart.data = {
                labels: labels,
                datasets: datasets
              }
              tideChart.update();
            }
            else {
              const ctx = document.getElementById('tideChart');

              tideChart = new Chart(ctx, {
                type: 'bar',
                data: {
                  labels: labels,
                  datasets: datasets
                },
                options: {
                  legend: {
                    display: false
                  },
                  title: {
                    display: true,
                    fontSize: 12,
                    padding: 0,
                    position: 'bottom',
                    text: stationInfo
                  },
                  scales: {
                    xAxes: [ {
                        gridLines: {
                          color: lineColors,
                          lineWidth: lineWidths
                        },
                        ticks: {
                          fontSize: 10,
                          maxTicksLimit: 4,
                          maxRotation: 0,
                          autoSkip: true,
                        }
                      }
                    ]
                  }
                }
              });

            }
          }
        }
        const xmlHttp = new XMLHttpRequest();
        xmlHttp.onreadystatechange = processWaterLevelStation;
        xmlHttp.open("GET", 'nearestWaterLevelStation/' + coord[1] + '/' + coord[0]);
        xmlHttp.send();
      }


      function updateCurrents(coord) {
        const xmlHttp = new XMLHttpRequest();
        xmlHttp.onreadystatechange = processCurrentsStation;
        xmlHttp.open('GET', 'nearestCurrentsStation/' + coord[1] + '/' + coord[0]);
        xmlHttp.send();
      }


      function processCurrentsStation(event) {
        const xmlHttp = event.currentTarget;
        if (xmlHttp.readyState == 4 && xmlHttp.status == 200) {
          console.log(xmlHttp.responseText);
          const station = JSON.parse(xmlHttp.responseText);
          const now = new Date();            
          const url = 
              'https://tidesandcurrents.noaa.gov/api/datagetter?product=currents'
              + formatRequestRange(now, station.Id);
          xmlHttp.onreadystatechange = processCurrents;
          xmlHttp.open('GET', url);
          xmlHttp.send();
        }
      }


      function processCurrents(event) {
        const xmlHttp = event.currentTarget;
        if (xmlHttp.readyState == 4 && xmlHttp.status == 200) {
          console.log(xmlHttp.responseText);
        }
      }


      function convertDMS(coords) {
        return ol.coordinate.toStringHDMS(coords);
      }

      function updateDefault() {
        if (!currentLocation) {
          currentLocation = [-122.4049, 47.6810] // Shilshole Bay
        }
        updateMap(currentLocation, 'images/view.png');
      }

      var geolocation = new Geolocation({
        onSuccess: function(coord) {
          if (coord.heading) {
            headingRotation = coord.heading * (Math.PI / 180);
          }
          if (coord.lon && coord.lat) {
            currentLocation = [ coord.lon, coord.lat ];
            updateMap(currentLocation);
          }
        },
        onError: function(err) {
          updateDefault();
        }
      });

      geolocation.start();
      updateDefault();

    </script>
  </body>
</html>

