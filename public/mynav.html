<!DOCTYPE html>
<html>
  <head>
    <title>Chart Navigator [Alpha]</title>
    
    <meta name="viewport" content="initial-scale=1.0, user-scalable=no, width=device-width">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-title" content="Ragnar [Alpha]">
    <link rel="apple-touch-icon" href="/images/sailboat.png">

    <link rel="stylesheet" href="lib/OpenLayers/4.2.0/ol.css" type="text/css">
    <link rel="stylesheet" href="stylesheets/alertify.core.css" type="text/css">
    <link rel="stylesheet" href="stylesheets/alertify.bootstrap.css" type="text/css">
    <link rel="stylesheet" href="stylesheets/bootstrap.min.css" type="text/css">
    <link rel="stylesheet" href="stylesheets/keyboard.min.css" type="text/css">

    <script src="javascripts/geolocation.js"></script>

    <script src="lib/alertify.min.js"></script>
    <script src="lib/OpenLayers/4.2.0/ol.js"></script>
    <script src="lib/Chart.js"></script>

    <script src="lib/jquery.min.js"></script>
    <script src="lib/jquery.keyboard.min.js"></script>
    <script src="lib/bootstrap.min.js"></script>

    <style>
      .alertify-button {
        background: rgba(0,65,135,.7);
        color: white;
      }
      .alertify-button-ok:focus {
        background: rgba(0,65,135,.9);
        color: white;
      }
      .alertify-button-ok:active {
        background: rgba(0,65,135,.95);
        color: white;
      }
      .alertify-button-ok:hover {
        background: rgba(0,65,135,1);
        color: white;
      }
      .ol-attribution ul {
        font-size: 100%;
        font-weight: bold;
        position: relative;
        bottom: 3px;
      }
      .ol-attribution a {
        display: none;
      }
      .popover-title {
        height: 30px;
        background:rgba(0,65,135,.5);
        color: white;
      }
      .popover-title .close {
        position: relative;
        bottom: 6px;
      } 
      .popover-title a {
        color: white;
        display: inline-block;
        opacity: 1;
      }
      .popover-content {
        min-width: 240px;
        font-size: 11px;
      }
      .ui-keyboard {
        background: white;
        background: -webkit-linear-gradient(rgba(0,65,135, .85), lightblue);
        top: 100%;
        left: -12.5%;
        border-radius: 8px;
        border: 1px solid;
        box-shadow: 2px 2px 2px rgba(50,50,50,.5);
      }
      .ui-keyboard-button {
        font-size: 1.35em;
      }
      .ui-keyboard-button:active {
        background: -webkit-linear-gradient(rgba(0,65,135,.5), gray);
        box-shadow: 1px 1px 1px gray;
        color:white;
      }
      .search-results {
        width: 100%;
      }
      .ol-zoom {
        background: gray;
      }
      .ol-zoom:hover {
        background: lightblue;
      }
      .ol-custom {
        background: gray;
      }
      .ol-custom:hover {
        background: lightblue;
      }
      .tide-chart {
        top: .5em;
        right: .5em;
        background: rgb(255,255,235);
        opacity: .95;
        width: 35%;
        border-radius: 8px;
        box-shadow: 3px 3px 4px rgba(50,50,50,.5);
      }
      .ol-touch .tide-chart {
        width: 85%;
        right: 0px;
      }
      .tablet .tide-chart {
        width: 35%;
      }
      .show-tide {
        top: .5em;
        right: .5em;
      }
      .ol-touch .show-tide {
        right: 0px;
      }
      .tablet .show-tide {
        right: 0px;
      }
      .tracking {
        top: 85px;
        left: .5em;
      }
      .ol-touch .tracking {
        top: 95px;
      }
      .search {
        top: 112px;
        left: .5em;
      }
      .ol-touch .search {
        top: 130px;
      }
      .destination {
        top: 140px;
        left: .5em;
      }
      .ol-touch .destination {
        top: 165px;
      }
      .chart {
        background-color: white;
        opacity: 0.7;
        visibility: hidden;
      }
      .location {
        background-color: yellow;
        font-weight: bold;
        font-size: 120%;
        font-family: monospace;
				bottom: 2em;
				left: .5em;
        opacity: .95;
      }
      .speed {
        bottom: 4em;
        left: .5em;
        width: 120px;
        height: 25px;
        text-align: center;
        font-size: 120%;
        font-weight: bold;
        font-family: monospace;
        color: white;
        background:rgba(0,65,135,.9);
        opacity: 0.8;
      }
      .speed:hover {
        color: black;
      }
      .set-course {
        position: absolute;
        left: .5em;
        top: .4em;
        color: white;
        background:rgba(0,65,135,.5);
        border-radius: 6px;
      }
    </style>
    <style type="text/css">
      html, body, .map {
        margin: 0;
        padding: 0;
        width: 100%;
        height: 100%;
      }
    </style>

  </head>
  <body>

    <div id="map" class="map"></div>
    <div style="display: none;">
      <div id="popup" class="popup"</div>
    </div>

    <script>
      const defaultZoom = 12;
      const locationTimeout = 3000;

      var chartTilesets = null; // current tilesets, stringified
      var chartLayers = [];     // current layers
      var marker = null;        // layer that marks current position
      var courseLayer = null;
      var destination = null;
      var map = null;           // the map object
      var popup = null;
      var selectedLocation = null;
      var prevLocationName = 'current location';
      var savedZoom = defaultZoom;
      var lastInteraction = null;


      /*****************************************************************
       * Tides information
       *****************************************************************/
      var waterLevelStation = null;
      var tideChart = null;
      var tideChartTime = new Date();
      var tideChartVisible = true;

      if (navigator.userAgent.match(/armv7/) ||
          navigator.userAgent.match(/ipad/i)) {
        var elem = document.getElementById('map');
        elem.className += ' tablet';
      }

      /**
       * Custom control for activating geolocation / gps tracking
       */
      const trackingControl = function(opt_options) {
        const options = opt_options || {};

        const button = document.createElement('button');
        const icon = document.createElement('img');
        icon.src = 'images/location-arrow.png';
        button.appendChild(icon);
        button.title = 'Track current location';
        var handler = function() {
          if (!geolocation.isTracking()) {
            map.getView().setZoom(savedZoom);
          }
          geolocation.stop();
          geolocation.start();
          lastInteraction = null;
        }
        button.addEventListener('click', handler, false);

        var element = document.createElement('div');
        element.className = 'tracking ol-custom ol-unselectable ol-control';
        element.appendChild(button);

        ol.control.Control.call(this, {
          element: element,
          target: options.target
        });
      }
      ol.inherits(trackingControl, ol.control.Control);
      
      /**
       * Custom control for searching for a specific location on the charts
       */
      const searchControl = function(opt_options) {
        //
        // Virtual keyboard layout
        //
        const kbdLayout = {
          "name" : "ms-US English (Latin)",
          "lang" : ["en"],
          "normal" : [
            "` 1 2 3 4 5 6 7 8 9 0 - = {bksp}",
            "q w e r t y u i o p [ ] \u005c",
            "a s d f g h j k l ; '",
            "{shift} \u005c z x c v b n m , . / {shift}",
            "{space}"
          ],
          "shift" : [
            "~ ! @ # $ % ^ & * ( ) _ + {bksp}",
            "Q W E R T Y U I O P { } |",
            "A S D F G H J K L : \u0022",
            "{shift} | Z X C V B N M < > / {shift}",
            "{space}"
          ]
        };      
        const options = opt_options || {};

        const button = document.createElement('button');
        const icon = document.createElement('img');
        icon.src = 'images/magnifier.png';
        button.appendChild(icon);
        button.title = 'Search';
        var handler = function() {
          alertify.prompt('', function(valid, value) {
            if (valid) {
              value = value.trim();
              searchLocation(value, selectedLocation);
            }
          });

          let form = document.getElementById('alertify-form');

          if (location.search === '?touch') {
            $('#alertify-text').keyboard({
              autoAccept: true,
              layout: 'custom',
              customLayout: kbdLayout,
              usePreview: false,
              visible: function(e, keyboard, el) {
                const kbdElem = document.getElementById('alertify-text_keyboard');
                form.appendChild(kbdElem);
              }
            });
          }
        }
        button.addEventListener('click', handler, false);

        var element = document.createElement('div');
        element.className = 'search ol-custom ol-unselectable ol-control';
        element.appendChild(button);

        ol.control.Control.call(this, {
          element: element,
          target: options.target
        });
      }
      ol.inherits(searchControl, ol.control.Control);

      /**
       * Custom control to show the current destination
       */
      const destControl = function(opt_options) {
        const options = opt_options || {};

        const button = document.createElement('button');
        const icon = document.createElement('img');
        icon.src = 'images/pointer-icon.png';
        button.appendChild(icon);
        button.title = 'Show destination';
        button.id = 'dest';
        var handler = function() {
          if (popup.place && destination) {
            if (popup.visible) {
              $(popup.getElement()).popover('destroy');
              popup.visible = popup.show = false;  
            }
            geolocation.stop();
            updateMap(popup.destCoord);
            updatePopup(destination, popup.destPlace, popup.destCoord);
          }
        }
        button.addEventListener('click', handler, false);

        var element = document.createElement('div');
        element.id = 'dest-div';
        element.className = 'destination ol-custom ol-unselectable ol-control';
        element.appendChild(button);
        element.style.visibility = 'hidden';

        ol.control.Control.call(this, {
          element: element,
          target: options.target
        });
      }
      ol.inherits(destControl, ol.control.Control);


      /**
       * Custom control for drawing water levels
       */
      const tideChartControl = function(opt_options) {
        const options = opt_options || {};

        const canvas = document.createElement('canvas');
        canvas.id = 'tideChart';
        var element = document.createElement('div');
        element.className = 'tide-chart ol-unselectable ol-control';
        element.appendChild(canvas);

        ol.control.Control.call(this, {
          element: element,
          target: options.target
        });
      }
      ol.inherits(tideChartControl, ol.control.Control);


      /**
       * Button for showing / hiding water levels (tide charts)
       */
      const showTideControl = function(opt_options) {
        const options = opt_options || {};

        const button = document.createElement('button');
        const icon = document.createElement('img');
        icon.src = 'images/right-arrow.png';
        button.appendChild(icon);
        button.title = 'Hide tide chart';
        var handler = function() {
          var elem = document.getElementById('tideChart').parentElement;
          if (!tideChartVisible) {
            elem.style.visibility = 'visible';
            icon.src = 'images/right-arrow.png';
            button.title = 'Hide tide chart';
          }
          else {
            elem.style.visibility = 'hidden';
            icon.src = 'images/left-arrow.png';
            button.title = 'Show tide chart';
          }
          tideChartVisible ^= true;
        }
        button.addEventListener('click', handler, false);

        var element = document.createElement('div');
        element.className = 'show-tide ol-custom ol-unselectable ol-control';
        element.appendChild(button);

        ol.control.Control.call(this, {
          element: element,
          target: options.target
        });
      }
      ol.inherits(showTideControl, ol.control.Control);


		  /**
			 * Custom control for displaying current location
			 */
			const locationControl = function(opt_options) {
				const options = opt_options || {};
				var element = document.createElement('div');
			  element.className = 'location ol-unselectable ol-control';
				element.id = 'location';
				element.innerHTML = convertDMS(options.coords);
				ol.control.Control.call(this, {
					element: element,
					target: options.target
				});
			}
			ol.inherits(locationControl, ol.control.Control);


      /**
			 * Custom control for displaying speed in knots
			 */
			const speedControl = function(opt_options) {
				const options = opt_options || {};
				var element = document.createElement('div');
			  element.className = 'speed ol-unselectable ol-control';
				element.id = 'speed';
        element.innerHTML = '0 kts';
				ol.control.Control.call(this, {
					element: element,
					target: options.target
				});
			}
			ol.inherits(speedControl, ol.control.Control);
				

      function getCourseLayer(pos, dest) {
        return new ol.layer.Vector({
          source: new ol.source.Vector({
            features: [
              new ol.Feature({
                geometry: new ol.geom.LineString([pos, dest])
              }),
              new ol.Feature({
                geometry: new ol.geom.Point(dest)
              }),
            ]
          }),
          style: new ol.style.Style({
            stroke: new ol.style.Stroke({
              color: 'green',
              width: 3
            }),
            image: new ol.style.Icon({
              anchor: [0.5, 1],
              anchorXUnits: 'fraction',
              anchorYUnits: 'fraction',
              src: 'images/pointer.png'
            })
          })
        });
      }


      function updateCourseLayer() {
        map.removeLayer(courseLayer);
        if (destination) {
          courseLayer = getCourseLayer(map.pos, destination);
          map.addLayer(courseLayer);
        }
      }


      function updatePositionLayer(pos) {
        if (marker) {
          map.removeLayer(marker);
        }
        marker = getPositionLayer(pos);
        map.addLayer(marker);
      }


      /**
       * Construct position marker layer
       */
      function getPositionLayer(xy) {
        let iconFeature = new ol.Feature({
          geometry: new ol.geom.Point(xy),
        });
        let rotation = 0;
        let iconUrl = 'images/view.png';
        if (geolocation.isTracking()) {
          iconUrl = 'images/marker.png';
          rotation = geolocation.rotation;
        }
        let iconStyle = new ol.style.Style({
          image: new ol.style.Icon({
            anchor: [0.5, 0.5],
            anchorXUnits: 'fraction',
            anchorYUnits: 'fraction',
            src: iconUrl,
            rotateWithView: true,
            rotation: rotation,
          })
        });
        iconFeature.setStyle(iconStyle);

        features = [iconFeature];

        if (destination && geolocation.coord && !geolocation.isTracking()) {
          xy = ol.proj.fromLonLat([geolocation.coord.lon, geolocation.coord.lat]);

          iconFeature = new ol.Feature({
            geometry: new ol.geom.Point(xy)
          });
          iconStyle = new ol.style.Style({
            image: new ol.style.Icon({
              anchor: [0.5, 0.5],
              anchorXUnits: 'fraction',
              anchorYUnits: 'fraction',
              src: 'images/marker.png',
              rotateWithView: true,
              rotation: geolocation.rotation
            })
          });
          iconFeature.setStyle(iconStyle);
          features.push(iconFeature);
        }

        return new ol.layer.Vector({
          source: new ol.source.Vector({
            features: features
          })
        });
      }


      function roundPoint(p, prec) {
        p[0] = Math.floor(p[0] * prec)/prec;
        p[1] = Math.floor(p[1] * prec)/prec;
      }

      /**
       * Ask the backend for the tilesets that match the current coordinates
       */ 
      function getChartTilesets(coord, extent, callback) {
        const minLonLat = ol.proj.transform([extent[0], extent[1]], 'EPSG:3857', 'EPSG:4326');
        const maxLonLat = ol.proj.transform([extent[2], extent[3]], 'EPSG:3857', 'EPSG:4326');

        roundPoint(minLonLat, 1000);
        roundPoint(maxLonLat, 1000);

        const tilesetsUrl = 'tilesets/noaa/' + coord[0] + '/' + coord[1]
          + '/' + minLonLat[0] + '/' + minLonLat[1]
          + '/' + maxLonLat[0] + '/' + maxLonLat[1];

        const xmlHttp = new XMLHttpRequest();
        xmlHttp.onreadystatechange = function() {
          if (xmlHttp.readyState === 4 && xmlHttp.status === 200) {
            callback(xmlHttp.responseText);
          }
        }
        xmlHttp.open('GET', tilesetsUrl);
        xmlHttp.send();
      }


      /**
       * Ask the backend for the best chart tilesets for the given coordinates
       * and recompute the chart layers if necessary (if tilesets changed).
       */
      function updateChartLayers(coord, view, callback) {
        const viewMaxRes = view.getMaxResolution();
        const extent = view.calculateExtent();

        getChartTilesets(coord, extent, function(tilesets) {
          if (tilesets !== chartTilesets) {
            chartTilesets = tilesets;
            console.log('----- Chart tilesets changed -----');
            //
            // remove old chart layers
            //
            if (map) {
              res = map.getView().getResolution();
              for (i = 0; i < chartLayers.length; ++i) {
                map.removeLayer(chartLayers[i]);
              }
              chartLayers = [];
            }

            let hMax = null;
            let maxRes = viewMaxRes;
            const extents = JSON.parse(tilesets);
            const sounding = extents.length===1 ? extents[0].sounding : null;
            //
            // apply new chart layers 
            //
            extents.map(function(tileset) {
              if (!hMax) {
                hMax = tileset.height;
              }
              maxRes = Math.ceil((tileset.height * viewMaxRes) / hMax);

              const url = 'tiles/noaa/' + tileset.ident + '/{z}/{x}/{y}';
              
              const layer = new ol.layer.Tile({
                source: new ol.source.XYZ({
                  url: url,
                  attributions: tileset.ident.split('_')[0] + (sounding ? ' Soundings in ' + sounding : '')
                }),
                maxResolution: maxRes,
                opacity: .95
              });
              layer.ident = tileset.ident;
              layer.upper = tileset.upper;
              layer.lower = tileset.lower;

              chartLayers.push(layer);
            })

            let prev = null;
            for (i = chartLayers.length - 1; i >= 0; --i) {
              let layer = chartLayers[i];
              if (prev) {
                if (layer.getMaxResolution() / prev.getMaxResolution() > 2) {
                  layer.setMinResolution(prev.getMaxResolution());
                }
                else {
                  layer.setMinResolution(prev.getMinResolution());
                }
              }
              console.log(i, layer.ident, layer.getMinResolution(), layer.getMaxResolution());
              prev = layer;
            }

            if (map) {
              for (i = 0; i != chartLayers.length; ++i) {
                let layer = chartLayers[i];
                map.addLayer(layer);
              }
            }
          }
          callback();
        });
      }


      function updateFeatures(pos) {
        updateCourseLayer();
        updatePositionLayer(pos);
      }

      /**
       * Construct / update the map object
       */
      function updateMap(coord) {
        if (popup && popup.visible) {
          $(popup.getElement()).popover('destroy');
          popup.visible = popup.shown = false;
        }

        let elem = document.getElementById('speed');
        if (elem) {
          elem.innerHTML = Math.floor(geolocation.speed * 100) / 100 + ' kts';
        }
        const pos = ol.proj.fromLonLat(coord);

        const view = map ? map.getView() : new ol.View({
          center: pos,
          zoom: defaultZoom,
          minZoom: 3,
          maxZoom: 18,
          enableRotation: false,
        });

        function update(view) {
          if (!view.updating) {
            view.updating = true;
            lastInteraction = new Date();
            updateChartLayers(selectedLocation, view, function() {
              updateFeatures(map.pos);
              map.render();
              view.updating = false;
            });
          }
        }

        view.on('change:center', update.bind(this, view));
        view.on('change:resolution', update.bind(this, view));

        if (!ol.extent.containsXY(view.calculateExtent(), pos[0], pos[1])) {
          const now = new Date();
          if (!lastInteraction || now.getTime() - lastInteraction.getTime() > 3 * 60 * 1000) {
            view.setCenter(pos);
          }
        }
       
        /**
         * Construct the base layer using map tiles from wikimedia
         * (or alternatively: use OpenStreetMaps, etc.) 
         */
        function baseLayer() {
          return new ol.layer.Tile({
            source: new ol.source.XYZ({url:'tiles/wikimedia/osm-intl/{z}/{x}/{y}'})
            
            //could use OpenStreetMaps too
            //source: new ol.source.XYZ({url:'tiles/osm/{a-c}/{z}/{x}/{y}.png'})
          });
        }

        updateChartLayers(coord, view, function() {
          const tideChartCtrl = new tideChartControl();

          if (!map) {
            map = new ol.Map({
              controls: ol.control.defaults({
                attributionOptions: {
                  collapsible: false,
                }}
              ).extend([
                tideChartCtrl,
                new showTideControl(),
								new locationControl({coords: coord}),
                new trackingControl(),
                new searchControl(),
                new destControl(),
                new speedControl(),
                /* new ol.control.ScaleLine({units: 'nautical'}) */
              ]),
              target: 'map',
              layers: [
                baseLayer(),
              ].concat(chartLayers),
              view: view
            });

            popup = new ol.Overlay({
              element: document.getElementById('popup')
            });
            map.addOverlay(popup);

            map.on('postrender', function() {
              showPopup();
            });

            //
            // Use double click to switch from location tracking to viewing mode
            //
            map.on('dblclick', function(e) {
              e.preventDefault();
              if (geolocation.isTracking()) {
                geolocation.stop();
                savedZoom = map.getView().getZoom();
                alertify.alert('Location tracking paused. Use the arrow button to resume.');
              }
              const coord = e.coordinate;
              const lonLat = ol.proj.transform(coord, 'EPSG:3857', 'EPSG:4326');
              selectedLocation = lonLat;
              prevLocationName = 'previous location';
              updateMap(lonLat);
            });
          }
          map.pos = pos;
          updateFeatures(pos);
        });
       
        elem = document.getElementById('location');
				if (elem) {
        	elem.innerHTML = convertDMS(coord);
				}
        updateWaterLevel(coord);

        //todo:
        // updateCurrents(coord);

        return pos;
			}


      function dateHelper(val) {
        return Math.floor(val / 10).toString() + (val % 10);
      }

      /**
       * Helper for formatting begin_date and end_date for water level requests
       */
      function formatDateTimeUTC(date) {
        const month = date.getUTCMonth() + 1;
        const day = date.getUTCDate();
        const hour = date.getUTCHours();
        const minute = date.getUTCMinutes()
        return date.getUTCFullYear().toString() + Math.floor(month / 10) + month % 10 + 
          + Math.floor(day / 10) + day % 10 + ' ' + Math.floor(hour / 10)
          + Math.floor(hour % 10) + ':' + Math.floor(minute / 10) + minute % 10;
      }


      function formatRequestRange(now, id) {
        now.setTime(now.getTime() - 12 * 3600 * 1000);
        const begin = formatDateTimeUTC(now);
        now.setTime(now.getTime() + 24 * 3600 * 1000);
        const end = formatDateTimeUTC(now);
        return '&begin_date=' + begin + '&end_date=' + end
          + '&time_zone=GMT&station=' + id + '&units=english&format=json';
      }


      /**
       * Update tide chart:
       * 1) ask the backend for the closest water level station to current location
       * 2) in response to the async request, processWaterLevelStation sends a 
       *    request to the NOAA web service, using a time interval centered around 
       *    the current time.
       */
      function updateWaterLevel(coord) {

        /**
         * Process response from backend.
         */
        function processWaterLevelStation(event) {
          const xmlHttp = event.currentTarget;
          
          if (xmlHttp.readyState === 4) {
            if (xmlHttp.status !== 200) {
              console.log(xmlHttp.response.text);
              return;
            }

            let s = JSON.parse(xmlHttp.responseText);

            const now = new Date();
            if (waterLevelStation && s.Id === waterLevelStation.Id) {
              //
              // same station? update every 30 minutes
              //
              if (now.getTime() - tideChartTime.getTime() < 30 * 60 * 1000) {
                return;
              }
            }
            waterLevelStation = s;
            tideChartTime = now;

            const stationInfo = 'Station: ' + s.Id + ' ' + s.Name + ' ' + s.State;

            const currentTime = now.toISOString();

            const useNOAAData = location.search == '?noaa';
            var url;
            if (useNOAAData) {
              url = 'https://tidesandcurrents.noaa.gov/api/datagetter?product=predictions&datum=MLLW' 
              + formatRequestRange(now, waterLevelStation.Id);
            } 
            else {
              url = 'tides/' + waterLevelStation.Id + '/' + currentTime;
            }
            console.log(url);

            xmlHttp.onreadystatechange = processWaterLevelRequest.bind(null, stationInfo);
            xmlHttp.open("GET", url);
            xmlHttp.send();
          }
        }

        
        /**
         * Process response from NOAA
         */
        function processWaterLevelRequest(stationInfo, event) {

          function tickDate(t) {
            const arr = t.split(/[- :]/);
            const date = new Date(arr[0], arr[1]-1, arr[2], arr[3], arr[4]);
            // Convert to local time
            date.setTime(date.getTime() - date.getTimezoneOffset() * 60000);
            const a = date.toString().split(' ');
            const timeString = a[0]
              + ' ' + dateHelper(date.getHours())
              + ':' + dateHelper(date.getMinutes());
                                  
            return [date, timeString];
          }

          const xmlHttp = event.currentTarget;

          if (xmlHttp.readyState===4 && xmlHttp.status===200) {
            const predictions = JSON.parse(xmlHttp.responseText).predictions;

            let labels = []
            const datasets = [ {
              data: [],
              borderColor: 'blue',
              borderWidth: 2,
              backgroundColor: 'rgba(0,65,135,.3)',
              pointBorderColor: 'black',
              pointBackgroundColor: 'orange',
              pointRadius: new Array(predictions.length).fill(0),
            } ]

            const now = new Date();
            const data = datasets[0].data;

            let closest = 0;
            for (let i = 0; i < predictions.length; ++i) {
              labels.push(predictions[i].t);
              data[i] = predictions[i].v;
              const t = tickDate(predictions[i].t);
              if (closest===0 && t[0].getTime() >= now.getTime()) {
                closest = i;
              }
            }
            let valMin = 99999;
            let iMin = closest;
            for (let i = closest; i < predictions.length; ++i) {
              const val = parseFloat(predictions[i].v);
              if (val < valMin) {
                iMin = i;
                valMin = val;
              }
              if (val > valMin) {
                if (iMin===closest) {
                  valMin = val;
                }
                else {
                  break;
                }
              }
            }
            let iMax = closest;
            let valMax = -99999;
            for (let i = closest; i < predictions.length; ++i) {
              const val = parseFloat(predictions[i].v);
              if (val > valMax) {
                iMax = i;
                valMax = val;
              }
              if (val < valMax) {
                if (iMax===closest) {
                  valMax = val;
                }
                else {
                  break;
                }
              }
            }
            
            function rebuildTicks(c) {
              function label(ticks, i) {
                return tickDate(ticks[i])[1];
              }
              const ticks = c.ticks;
              c.ticks = [];
              c.ticks[0] = ['', label(ticks, 0)];
              c.ticks[closest] = ['', label(ticks, closest)];
              c.ticks[ticks.length-1] = ['', label(ticks, ticks.length-1)];
              c.ticks[iMin] = label(ticks, iMin).split(' ')[1];
              c.ticks[iMax] = label(ticks, iMax).split(' ')[1];
            }


            datasets[0].pointRadius[closest] = 6;

            const ctx = document.getElementById('tideChart');

            if (tideChart) {
              tideChart.destroy();
            }
            tideChart = new Chart.Line(ctx, {

              data: {
                labels: labels,
                datasets: datasets
              },

              options: {

                animation: {
                  duration: 0,

                  onComplete: function() {
                    const ctx = this.chart.ctx;
                    const fillStyle = ctx.fillStyle;
                    const font = ctx.font;
                    ctx.fillStyle = 'navy';
                    ctx.font = 'bold 18px calibri';
                    const meta = this.getDatasetMeta(0);
                    for (let i = 0; i != meta.data.length; ++i) {
                      if (meta.data[i]._model.radius < 6) {
                        continue;
                      }
                      const data = this.data.datasets[0].data;
                      const value = Math.ceil(10 * data[i]) / 10 + "'";
                      ctx.fillText(value, 35, 25);
                      break;
                    }
                    ctx.fillStyle = fillStyle;
                    ctx.font = font;
                  }
                },
                legend: {
                  display: false
                },
                title: {
                  display: true,
                  fontSize: 12,
                  padding: 0,
                  position: 'bottom',
                  text: stationInfo
                },
                tooltips: {
                  callbacks: {
                    title: function(items, data) {
                      const val = tickDate(data.labels[items[0].index])[1];
                      return val;
                    }
                  }
                },

                scales: {
                  yAxes: [ {
                      gridLines: {
                        color: 'lightblue',
                      },
                    }
                  ],

                  xAxes: [ {
                      gridLines: {
                        color: 'blue',
                      },

                      ticks: {
                        fontSize: 12,
                        maxRotation: 0,
                        autoSkip: false,
                      },

                      afterBuildTicks: rebuildTicks
                    },
                  ]
                },
              },
            });
          }
        }
        const xmlHttp = new XMLHttpRequest();
        xmlHttp.onreadystatechange = processWaterLevelStation;
        xmlHttp.open("GET", 'nearestWaterLevelStation/' + coord[1] + '/' + coord[0]);
        xmlHttp.send();
      }


      function updateCurrents(coord) {
        const xmlHttp = new XMLHttpRequest();
        xmlHttp.onreadystatechange = processCurrentsStation;
        xmlHttp.open('GET', 'nearestCurrentsStation/' + coord[1] + '/' + coord[0]);
        xmlHttp.send();
      }


      function processCurrentsStation(event) {
        const xmlHttp = event.currentTarget;
        if (xmlHttp.readyState === 4 && xmlHttp.status === 200) {
          console.log(xmlHttp.responseText);
          const station = JSON.parse(xmlHttp.responseText);
          const now = new Date();            
          const url = 
              'https://tidesandcurrents.noaa.gov/api/datagetter?product=currents'
              + formatRequestRange(now, station.Id);
          xmlHttp.onreadystatechange = processCurrents;
          xmlHttp.open('GET', url);
          xmlHttp.send();
        }
      }


      function processCurrents(event) {
        const xmlHttp = event.currentTarget;
        if (xmlHttp.readyState === 4 && xmlHttp.status === 200) {
          console.log(xmlHttp.responseText);
        }
      }


      function showPopup() {
        if (popup.visible && !popup.shown) {
          popup.shown = true;
          const elem = popup.getElement();
          $(elem).popover('show');
          function closePopup() {
            $(elem).popover('destroy'); 
            popup.visible = popup.shown = false;
          }
          function setDestination(pos) {
            closePopup();
            destination = pos;
            if (destination) {
              // TODO: move these to another namespace
              popup.destPlace = popup.place;
              popup.destCoord = popup.coord;
            }
            geolocation.start();
            lastInteraction = null;
          }
          document.getElementById('close-popup').onclick = function() {
            closePopup();
          }
          document.getElementById('set-course').onclick = function() {
            setDestination(popup.getPosition());
            document.getElementById('dest-div').style.visibility = 'visible';
          }
          document.getElementById('cancel-course').onclick = function() {
            setDestination(null);
            document.getElementById('dest-div').style.visibility = 'hidden';
          }
        }
      }

      function getDistanceFromLonLat(coord1, coord2) {
       
        const lon1 = coord1[0];
        const lat1 = coord1[1];
        const lon2 = coord2[0];
        const lat2 = coord2[1];

        function deg2rad(deg) {
          return deg * (Math.PI/180)
        }

        const dLat = deg2rad(lat2-lat1);  // deg2rad below
        const dLon = deg2rad(lon2-lon1); 
        const a = 
          Math.sin(dLat/2) * Math.sin(dLat/2) +
          Math.cos(deg2rad(lat1)) * Math.cos(deg2rad(lat2)) * 
          Math.sin(dLon/2) * Math.sin(dLon/2); 
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a)); 
        return c;
      }

      function updatePopup(pos, place, coord) {
        popup.place = place;
        popup.coord = coord;

        const e = popup.getElement();

        const elevation = place.elevation < 0 ? 0 : place.elevation;
        //contrary to docs from geonames.org, elevation seems to be in feet, not meters
        //otherwise we should multiply by 3.28084 -- I just checked a few data points
        //against Wikipedia

        let html = '<b>' + place.name + '</b>';
        if (place.state) {
          html += ', ' + place.state;
        }
        html += '<br>' + convertDMS(coord);

        function distance(d) {
          if (d===0) {
            const coord = [ geolocation.coord.lon, geolocation.coord.lat ];
            d = getDistanceFromLonLat(popup.coord, coord) * 3440;
            prevLocationName = 'current location';
          }
          return '<br>' + Math.floor(d * 100) / 100
            + ' nautical miles from ' + prevLocationName + '.';

        }
        let btn = '';

        if (destination && pos[0]===destination[0] && pos[1]===destination[1]) {
          const d = getDistanceFromLonLat(popup.destCoord, selectedLocation) * 3440;
          html += distance(d);
          html += '<div id="set-course" display: none></div>';
          btn  += '<button type="button" class="set-course" id="cancel-course">Cancel course</button>';
          prevLocationName = popup.destPlace.name;
          if (popup.destPlace.state) prevLocationName += ', ' + popup.destPlace.state;
        }
        else {
          html += distance(place.dist);
          html += '<div id="cancel-course" display: none></div>';
          btn += '<button type="button" class="set-course" id="set-course">Set course</button>';
          prevLocationName = place.name;
          if (place.state) prevLocationName += ', ' + place.state;
        }
        selectedLocation = coord;

        $(e).popover({
          'animation': false,
          'html': true,
          'placement': 'top',
          'content': html,
          'title': btn + '<a href="#" id="close-popup" class="close">&times;</a>'
        });
        popup.setPosition(pos);
        popup.shown = false;
        popup.visible = true; // popover on map postrender
        map.getView().setCenter(pos);

        const imageUrl = '/images/wu_logo_130x80.png';

        const xmlHttp = new XMLHttpRequest();
        xmlHttp.onreadystatechange = function() {
          if (xmlHttp.readyState === 4 && xmlHttp.status === 200) {
            const w = JSON.parse(xmlHttp.responseText);
            html += '<b>Weather</b><image width="18%" src="' + imageUrl + '"/> ';
            html += w.weather + '<br>' + w.temp
              + ' Humidity: ' + w.humidity
              + ' Wind: ' + w.wind + ' (direction ' + w.wind_degrees + '&deg;)'
              + ' Visibility: ' + w.visibility + ' miles'
              + '. <i>Station: ' + w.station + '</i>';

            $(e).popover('destroy');
            $(e).popover({
              'animation': false,
              'html': true,
              'placement': 'top',
              'content': html,
              'title': btn + '<a href="#" id="close-popup" class="close">&times;</a>'
            });
            popup.shown = false;
            map.render();
          }
        }
        xmlHttp.open('GET', '/weather/' + coord[0] + '/' + coord[1]);
        xmlHttp.send();
      }


      function searchLocation(name, coord) {

        function buildSelection(matches) {
          let selectHtml = '<b>Nearest Matches</b><br>';
          selectHtml += '<select id="searchResults" class="search-results">';
          for (let i = 0; i < matches.length; ++i) {
            const m = matches[i];
            selectHtml += '<option value="[' + m.lon + ',' + m.lat + ']">';
            selectHtml += m.name;
            if (m.stateName) {
              selectHtml += ', ' + m.stateName;
            }
            if (m.state) {
              selectHtml += ' (' + m.state + ')';
            }
            selectHtml += '</option>';
          }
          selectHtml += '</select>';
          return selectHtml;
        }

        const url = 'search/' + name + '/' + coord[0] + '/' + coord[1];
        const xmlHttp = new XMLHttpRequest();
        xmlHttp.onreadystatechange = function() {
          if (xmlHttp.readyState === 4 && xmlHttp.status === 200) {
            const matches = JSON.parse(xmlHttp.responseText);
            if (matches && matches.length) {
              const selectHtml = buildSelection(matches);
              
              alertify.confirm(selectHtml, function(accept) {
                if (!accept) {
                  return;
                }
                const elem = document.getElementById('searchResults');
                const coord = JSON.parse(elem.options[elem.selectedIndex].value);
                if (geolocation.isTracking()) {
                  geolocation.stop();
                }
                if (map && map.getView().getZoom() < defaultZoom) {
                    map.getView().setZoom(defaultZoom);
                }
                const pos = updateMap(coord);
                updatePopup(pos, matches[elem.selectedIndex], coord);
              });
            }
            else {
              alertify.alert('<b>No matches</b>');
            }
          }
        }
        xmlHttp.open('GET', url);
        xmlHttp.send();
      }
      
      
      function convertDMS(coords) {
        return ol.coordinate.toStringHDMS(coords);
      }


      function updateDefault() {
        if (!selectedLocation) {
          selectedLocation = [-122.4049, 47.6810] // Shilshole Bay
          prevLocationName = 'Shilshole Bay';
        }
        updateMap(selectedLocation);
      }


      var geolocation = new Geolocation({
        onSuccess: function(coord) {
          if (coord.lon && coord.lat) {
            selectedLocation = [ coord.lon, coord.lat ];
            prevLocationName = 'current location';
            updateMap(selectedLocation);
          }
        },
        onError: function(err) {
          updateDefault();
        }
      });


      updateDefault();
      geolocation.start();

    </script>
  </body>
</html>

