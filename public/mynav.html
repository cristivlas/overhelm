<!DOCTYPE html>
<html>
  <head>
    <title>My Nav App</title>
    <!-- link rel="stylesheet" href="https://openlayers.org/en/v4.1.1/css/ol.css" type="text/css" -->
    <link rel="stylesheet" href="lib/OpenLayers/4.2.0/ol.css" type="text/css">
    <!-- The line below is only needed for old environments like Internet Explorer and Android 4.x -->
    <!-- script src="https://cdn.polyfill.io/v2/polyfill.min.js?features=requestAnimationFrame,Element.prototype.classList,URL"></script -->
    <!-- script src="https://openlayers.org/en/v4.1.1/build/ol.js"></script-->
    <script src="lib/OpenLayers/4.2.0/ol.js"></script>
  </head>
  <body>
    <div id="location" style="font-size: 200%;"></div>
    <div id="map" class="map" style="height: 100%; width: 100%; position: fixed">
    </div>
    <script>
      var chartTilesets = null; // current tilesets, stringified
      var chartLayers = [];     // current layers
      var marker = null;        // layer that marks current position
      var map = null;           // the map object

      /**
       * Construct position marker layer
       */
      function curPosLayer(coord) {
        var iconFeature = new ol.Feature({
          geometry: new ol.geom.Point(coord),
          name: 'Current position',
        });

      function isHandHeld() { 
        if( navigator.userAgent.match(/Android/i)
          || navigator.userAgent.match(/webOS/i)
          || navigator.userAgent.match(/iPhone/i)
       // || navigator.userAgent.match(/iPad/i)
          || navigator.userAgent.match(/iPod/i)
          || navigator.userAgent.match(/BlackBerry/i)
          || navigator.userAgent.match(/Windows Phone/i)){
          return true;
         }
         else {
           return false;
         }
        }
        const iconUrl = isHandHeld() ? 'images/pointer-large.png' : 'images/pointer.png';

        var iconStyle = new ol.style.Style({
          image: new ol.style.Icon(/** @type {olx.style.IconOptions} */ ({
            anchor: [0.5, 46],
            anchorXUnits: 'fraction',
            anchorYUnits: 'pixels',
            src: iconUrl
          }))
        });
        iconFeature.setStyle(iconStyle);

        var vectorSource = new ol.source.Vector({
          features: [iconFeature]
        });

        return new ol.layer.Vector({
          source: vectorSource,
        });
      }


      /**
       * Ask the backend for the tilesets that match the current coordinates
       */ 
      function getChartTilesets(coord, callback) {
        const tilesetsUrl = 'tilesets/noaa/' + coord[0] + '/' + coord[1];
        var xmlHttp = new XMLHttpRequest();
        xmlHttp.onreadystatechange = function() {
          if (xmlHttp.readyState == 4 && xmlHttp.status == 200) {
            callback(xmlHttp.responseText);
          }
        }
        xmlHttp.open("GET", tilesetsUrl);
        xmlHttp.send();
      }

      /**
       * Ask the backend for the best chart tilesets for the given coordinates
       * and recompute the chart layers if necessary (if tilesets changed).
       */
      function updateChartLayers(coord, callback) {
        /**
         * Heuristics for min/max resolutions
         */
        function getMinResolution(tileset) {
          var minRes = Math.floor(tileset.height / 50) * 5000;
          //console.log(tileset.ident, tileset.height, minRes);
          return minRes;
        }

        function getMaxResolution(tileset) {
          var maxRes = Math.floor(tileset.height * 1000);
          //console.log(tileset.ident, tileset.height, maxRes);
          return maxRes;
        }

        getChartTilesets(coord, function(tilesets) {
          if (tilesets !== chartTilesets) {
            console.log('Tilesets have changed');
            chartTilesets = tilesets;
            if (map) {
              for (i = 0; i < chartLayers.length; ++i) {
                map.removeLayer(chartLayers[i]);
              }
              chartLayers = [];
            }

            JSON.parse(tilesets).map(function(tileset) {
              const url = 'tiles/noaa/' + tileset.ident + '/{z}/{x}/{y}.png';
              const layer = new ol.layer.Tile({
                source: new ol.source.XYZ({url: url}),
                opacity: 0.75,
                minResolution: getMinResolution(tileset),
                maxResolution: getMaxResolution(tileset)
              });
              chartLayers.push(layer);
            })
            if (map) {
              for (i = 0; i != chartLayers.length; ++i) {
                map.addLayer(chartLayers[i]);
              }
            }
          }
          callback();
        });
      }


      /**
       * Construct / update the map object
       */
      function updateMap(coord) {
    
        const pos = ol.proj.fromLonLat(coord);
        updateChartLayers(coord, function() {
          if (!map) {
            var view = new ol.View({
              center: pos,
              zoom: 12,
              minZoom: 2,
              maxZoom: 15,
              enableRotation: false
            });

            //view.on('change:resolution', function(event) {
            //  console.log(view.getResolution());
            //});
            
            map = new ol.Map({
              target: 'map',
              // get base layer from Open Street Maps and append the chart layers
              layers: [new ol.layer.Tile({
                source: new ol.source.OSM()
                })].concat(chartLayers),
              view: view
            });
          }

          if (marker) {
            map.removeLayer(marker);
          }
          marker = curPosLayer(pos);
          map.addLayer(marker);
        });
      }

      /**
       * Convert decimal coords to degree,minutes,seconds
       * 
       * Credits: en.marnoto.com
       */
      function getDMS(val) {
         val = Math.abs(val);

         var valDeg = Math.floor(val);

         // Add the degrees value to the result by adding the degrees symbol
         var result = valDeg + '&deg;';

         // Minutes
         // Removing the integer of the initial value you get the decimal portion.
         // Multiply the decimal portion by 60.
         // Math.floor returns an integer discarding the decimal portion.
         var valMin = Math.floor((val - valDeg) * 60);

         // Add minutes to the result, adding the symbol minutes "'".
         result += valMin + "'";

         // Seconds
         var valSec = Math.round((val - valDeg - valMin / 60) * 3600 * 1000) / 1000;

         // Add the seconds value to the result, adding the seconds symbol
         result += valSec + '"';

         return result;
      }

      function convertDMS(coords) {
        return getDMS(coords[1]) + (coords[1] >= 0 ? 'N' : 'S') + ' / ' 
             + getDMS(coords[0]) + (coords[0] >= 0 ? 'E' : 'W')
      }

      /** 
       * Track geolocation
       */
      function geoLocationUpdate(position) {
        console.log(position);
        coords = [position.coords.longitude, position.coords.latitude];
        var elem = document.getElementById('location');
        elem.innerHTML = convertDMS(coords);
        updateMap(coords);
      }

      function geoLocationError(error) {
        console.log(error, error.message);
        alert(error.message);
      }

      const geoLocationOptions = {
        enableHighAccuracy: true,
        timeout: 1000,
        maximumAge: 2000,
      };

      navigator.geolocation.watchPosition(geoLocationUpdate, geoLocationError, geoLocationOptions);
    </script>
  </body>
</html>

